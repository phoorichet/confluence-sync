# Story 1.3: OpenAPI Client Generation & Setup

## Status
Ready for Review

## Story
**As a** developer,
**I want** auto-generated TypeScript types from Confluence OpenAPI spec,
**so that** I have type-safe API interactions.

## Acceptance Criteria
1. Script to download latest Confluence OpenAPI specification implemented
2. OpenAPI TypeScript generation configured to output to src/types/confluence.ts
3. openapi-fetch client initialized with authentication headers
4. Type-safe wrapper functions created for core API operations (getPage, updatePage)
5. Error handling middleware added for API responses
6. Rate limiting compliance built into client (respecting 5000 req/hour)
7. Generated types successfully compile with strict TypeScript settings

## Tasks / Subtasks
- [x] Set up OpenAPI spec management (AC: 1, 2)
  - [x] Create scripts/download-openapi.ts to fetch latest Confluence OpenAPI spec from Atlassian
  - [x] Save downloaded spec to src/openapi/confluence-openapi.json
  - [x] Create scripts/generate-types.ts using openapi-typescript to generate TypeScript types
  - [x] Configure type generation to output to src/api/types.ts (not src/types/confluence.ts for consistency)
  - [x] Add npm scripts: "download:openapi" and "gen:openapi" to package.json
  - [x] Test that generated types compile with strict TypeScript settings
- [x] Initialize openapi-fetch client (AC: 3, 4)
  - [x] Install openapi-fetch (0.9.0) and openapi-typescript (6.7.0) dependencies
  - [x] Create src/api/client.ts with openapi-fetch client initialization
  - [x] Integrate AuthManager from src/auth/auth-manager.ts to provide authentication headers
  - [x] Configure client with proper base URL handling for Cloud vs Server instances
  - [x] Create type-safe wrapper functions: getPage(), updatePage(), getSpace(), searchPages()
  - [x] Ensure all wrapper functions use the generated types from src/api/types.ts
- [x] Implement error handling middleware (AC: 5)
  - [x] Create src/api/circuit-breaker.ts implementing circuit breaker pattern (open after 5 failures, half-open after 30s)
  - [x] Add error mapping to convert HTTP status codes to user-friendly messages with CS-XXX error codes
  - [x] Implement exponential backoff with jitter (max 3 retries) for transient failures
  - [x] Set timeout configurations: 30s for single page, 5min for bulk operations
  - [x] Create custom error classes extending base Error with CS-XXX codes
  - [x] Ensure no sensitive data (tokens, passwords) appears in error messages
- [x] Implement rate limiting (AC: 6)
  - [x] Create src/api/rate-limiter.ts using p-limit (5.0.0) library
  - [x] Configure rate limiter to respect 5000 requests/hour for Cloud instances
  - [x] Implement token bucket algorithm with refill rate calculation
  - [x] Add rate limit headers parsing from API responses
  - [x] Handle 429 (Too Many Requests) responses with automatic retry after delay
  - [x] Add logging for rate limit approaching warnings (at 80% and 95% thresholds)
- [x] Create comprehensive tests (AC: 7)
  - [x] Create tests/unit/api/client.test.ts for API client unit tests
  - [x] Create tests/unit/api/rate-limiter.test.ts for rate limiting logic tests
  - [x] Create tests/unit/api/circuit-breaker.test.ts for circuit breaker tests
  - [x] Create tests/integration/api/confluence-api.test.ts using MSW for mock server
  - [x] Test authentication header injection for both Cloud and Server
  - [x] Test error handling for various HTTP status codes (401, 403, 404, 429, 500)
  - [x] Test rate limiting behavior under high request load
  - [x] Verify generated types compile and provide proper type safety

## Dev Notes

### Previous Story Insights
From Story 1.2 completion:
- AuthManager implemented in src/auth/auth-manager.ts with methods: authenticate(), getToken(), clearCredentials(), validateAuth()
- Authentication supports both Cloud (Basic Auth with email:api_token) and Server (Bearer token with PAT)
- Credentials stored securely using @zowe/secrets-for-zowe-sdk
- API client needs to be updated to use AuthManager for credentials
- Error codes (CS-XXX) pattern established for consistent error handling
- Logger utility created in src/utils/logger.ts with sanitization to prevent secrets in logs

### Project Structure
Based on architecture, API-related files should be created in:
[Source: architecture/source-tree.md]
```
src/
├── api/
│   ├── client.ts           # openapi-fetch client setup
│   ├── types.ts            # Auto-generated Confluence types
│   ├── rate-limiter.ts     # Rate limiting logic
│   └── circuit-breaker.ts  # Circuit breaker implementation
├── openapi/
│   └── confluence-openapi.json  # Downloaded OpenAPI spec
└── scripts/
    ├── download-openapi.ts  # Download Confluence OpenAPI script
    └── generate-types.ts    # Generate TypeScript from OpenAPI
```

### Libraries and Dependencies
[Source: architecture/tech-stack.md#Technology Stack Table]
- **openapi-fetch 0.9.0**: Type-safe Confluence API calls with auto-generated types
- **openapi-typescript 6.7.0**: Generate TypeScript types from OpenAPI specification
- **p-limit 5.0.0**: Concurrent operation control for rate limiting and preventing API overload
- **MSW (Mock Service Worker)**: For integration testing with mock Confluence API

### API Client Requirements
[Source: architecture/components.md#API Client]
The API Client component must:
- Handle all Confluence API interactions with type safety, rate limiting, and error handling
- Implement key interfaces: getPage(), updatePage(), getSpace(), searchPages()
- Use openapi-fetch with auto-generated types
- Implement circuit breaker pattern for resilience

### Confluence API Details
[Source: architecture/external-apis.md#Confluence REST API]
- **Cloud instances** (*.atlassian.net):
  - Base URL: `https://{domain}.atlassian.net/wiki/api/v2`
  - Rate limit: 5000 requests per hour per user
  - Authentication: OAuth 2.0 or API Token with Basic Auth
- **Server instances** (custom domains):
  - Base URL: `https://{server}/rest/api`
  - No hard rate limit (instance-dependent)
  - Authentication: Personal Access Token or Basic Auth
- **Important considerations**:
  - Handle both storage format (XHTML) and view format (HTML)
  - Version number must be incremented on updates to prevent conflicts
  - Use `expand` parameter to reduce API calls
  - Cache frequently accessed metadata to minimize API calls

### Error Handling Requirements
[Source: architecture/error-handling-strategy.md#External API Errors]
[Source: architecture/error-handling-strategy.md#General Approach]
- **Circuit Breaker**: Open after 5 consecutive failures, half-open after 30s
- **Retry Strategy**: Exponential backoff with jitter, max 3 retries
- **Timeouts**: 30s for single page, 5min for bulk operations
- **Error Codes**: Use CS-XXX pattern for all errors
- Map HTTP status codes to user-friendly messages
- Never expose sensitive data in error messages

### Critical Implementation Rules
[Source: architecture/coding-standards.md#Critical Rules]
- Always use apiClient for API calls - never use fetch directly
- All API responses must use type guards - never cast API responses directly, validate with zod schemas
- Every API call must go through the rate-limited client
- Every error must have a CS-XXX error code
- No secrets in logs or error messages

### Testing

### Testing Standards
[Source: architecture/test-strategy-and-standards.md]

**Test Framework**: Vitest 1.2.0

**Unit Tests**:
- Location: `tests/unit/api/` mirroring `src/api/` structure
- Mock all external dependencies
- Test file naming: `{module}.test.ts`
- Focus on edge cases and error conditions

**Integration Tests**:
- Location: `tests/integration/api/`
- Use MSW (Mock Service Worker) for mocking Confluence API
- Test complete API workflows including authentication
- Verify rate limiting and error handling behaviors

**Required Test Coverage**:
- All wrapper functions with various input scenarios
- Rate limiting behavior under load
- Circuit breaker state transitions
- Error handling for all HTTP status codes
- Authentication header injection
- Type safety verification

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-07 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.1 (James - Developer Agent)

### Debug Log References
- Fixed URL for downloading OpenAPI spec (changed from swagger.json to correct v3.json endpoint)
- Integration tests required mocking fix for AuthManager
- ESLint auto-fixed formatting issues
- Added eslint-disable to auto-generated types file

### Completion Notes List
- Successfully downloaded Confluence OpenAPI specification v2.0.0
- Generated TypeScript types using openapi-typescript 6.7.0
- Implemented openapi-fetch client with full authentication integration
- Circuit breaker pattern implemented with 5 failure threshold and 30s reset
- Rate limiter respects 5000 req/hour for Cloud instances with token bucket algorithm
- Error mapper sanitizes sensitive data from error messages
- All tests passing (54 unit tests, 11 integration tests)
- Project builds successfully with zshy

### File List
- Created: scripts/download-openapi.ts
- Created: scripts/generate-types.ts
- Created: src/api/client.ts
- Created: src/api/circuit-breaker.ts
- Created: src/api/rate-limiter.ts
- Created: src/api/types.ts (auto-generated)
- Created: src/openapi/confluence-openapi.json (downloaded)
- Created: tests/unit/api/client.test.ts
- Created: tests/unit/api/circuit-breaker.test.ts
- Created: tests/unit/api/rate-limiter.test.ts
- Created: tests/integration/api/confluence-api.test.ts
- Created: tests/integration/api/basic-api.test.ts
- Modified: package.json (added dependencies and scripts)

## QA Results
