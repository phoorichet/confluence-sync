/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/admin-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Admin Key
         * @description Returns information about the admin key if one is currently enabled for the calling user within the site.
         *
         *     **[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
         *     User must be an organization or site admin.
         */
        get: operations["getAdminKey"];
        put?: never;
        /**
         * Enable Admin Key
         * @description Enables admin key access for the calling user within the site. If an admin key already exists for the user, a new one will be issued with an updated expiration time.
         *
         *     **Note:** The `durationInMinutes` field within the request body is optional. If the request body is empty or if the `durationInMinutes` is set to 0 minutes, a new admin key will be issued to the calling user with a default duration of 10 minutes.
         *
         *     **[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
         *     User must be an organization or site admin.
         */
        post: operations["enableAdminKey"];
        /**
         * Disable Admin Key
         * @description Disables admin key access for the calling user within the site.
         *
         *     **[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
         *     User must be an organization or site admin.
         */
        delete: operations["disableAdminKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachments
         * @description Returns all attachments. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the container of the attachment.
         */
        get: operations["getAttachments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachment by id
         * @description Returns a specific attachment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the attachment's container.
         */
        get: operations["getAttachmentById"];
        put?: never;
        post?: never;
        /**
         * Delete attachment
         * @description Delete an attachment by id.
         *
         *     Deleting an attachment moves the attachment to the trash, where it can be restored later. To permanently delete an attachment (or "purge" it),
         *     the endpoint must be called on a **trashed** attachment with the following param `purge=true`.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the container of the attachment.
         *     Permission to delete attachments in the space.
         *     Permission to administer the space (if attempting to purge).
         */
        delete: operations["deleteAttachment"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{id}/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get labels for attachment
         * @description Returns the labels of specific attachment. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the parent content of the attachment and its corresponding space.
         *     Only labels that the user has permission to view will be returned.
         */
        get: operations["getAttachmentLabels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for attachment
         * @description Returns the permitted operations on specific attachment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the parent content of the attachment and its corresponding space.
         */
        get: operations["getAttachmentOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{attachment-id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for attachment
         * @description Retrieves all Content Properties tied to a specified attachment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the attachment.
         */
        get: operations["getAttachmentContentProperties"];
        put?: never;
        /**
         * Create content property for attachment
         * @description Creates a new content property for an attachment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the attachment.
         */
        post: operations["createAttachmentProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{attachment-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for attachment by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified attachment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the attachment.
         */
        get: operations["getAttachmentContentPropertiesById"];
        /**
         * Update content property for attachment by id
         * @description Update a content property for attachment by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the attachment.
         */
        put: operations["updateAttachmentPropertyById"];
        post?: never;
        /**
         * Delete content property for attachment by id
         * @description Deletes a content property for an attachment by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to attachment the page.
         */
        delete: operations["deleteAttachmentPropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{id}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachment versions
         * @description Returns the versions of specific attachment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the attachment and its corresponding space.
         */
        get: operations["getAttachmentVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{attachment-id}/versions/{version-number}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get version details for attachment version
         * @description Retrieves version details for the specified attachment and version number.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the attachment.
         */
        get: operations["getAttachmentVersionDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{id}/footer-comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachment comments
         * @description Returns the comments of the specific attachment.
         *     The number of results is limited by the `limit` parameter and additional results (if available) will be available through
         *     the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the attachment and its corresponding containers.
         */
        get: operations["getAttachmentComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get blog posts
         * @description Returns all blog posts. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only blog posts that the user has permission to view will be returned.
         */
        get: operations["getBlogPosts"];
        put?: never;
        /**
         * Create blog post
         * @description Creates a new blog post in the space specified by the spaceId.
         *
         *     By default this will create the blog post as a non-draft, unless the status is specified as draft.
         *     If creating a non-draft, the title must not be empty.
         *
         *     Currently only supports the storage representation specified in the body.representation enums below
         */
        post: operations["createBlogPost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get blog post by id
         * @description Returns a specific blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the blog post and its corresponding space.
         */
        get: operations["getBlogPostById"];
        /**
         * Update blog post
         * @description Update a blog post by id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the blog post and its corresponding space. Permission to update blog posts in the space.
         */
        put: operations["updateBlogPost"];
        post?: never;
        /**
         * Delete blog post
         * @description Delete a blog post by id.
         *
         *     By default this will delete blog posts that are non-drafts. To delete a blog post that is a draft, the endpoint must be called on a
         *     draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.
         *
         *     Deleting a blog post that is not a draft moves the blog post to the trash, where it can be restored later.
         *     To permanently delete a blog post (or "purge" it), the endpoint must be called on a **trashed** blog post with the following param `purge=true`.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the blog post and its corresponding space.
         *     Permission to delete blog posts in the space.
         *     Permission to administer the space (if attempting to purge).
         */
        delete: operations["deleteBlogPost"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachments for blog post
         * @description Returns the attachments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the blog post and its corresponding space.
         */
        get: operations["getBlogpostAttachments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/custom-content": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get custom content by type in blog post
         * @description Returns all custom content for a given type within a given blogpost. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content, the container of the custom content (blog post), and the corresponding space.
         */
        get: operations["getCustomContentByTypeInBlogPost"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get labels for blog post
         * @description Returns the labels of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the blog post and its corresponding space.
         *     Only labels that the user has permission to view will be returned.
         */
        get: operations["getBlogPostLabels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/likes/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get like count for blog post
         * @description Returns the count of likes of specific blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the blog post and its corresponding space.
         */
        get: operations["getBlogPostLikeCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/likes/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get account IDs of likes for blog post
         * @description Returns the account IDs of likes of specific blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the blog post and its corresponding space.
         */
        get: operations["getBlogPostLikeUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{blogpost-id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for blog post
         * @description Retrieves all Content Properties tied to a specified blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the blog post.
         */
        get: operations["getBlogpostContentProperties"];
        put?: never;
        /**
         * Create content property for blog post
         * @description Creates a new property for a blogpost.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the blog post.
         */
        post: operations["createBlogpostProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{blogpost-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for blog post by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the blog post.
         */
        get: operations["getBlogpostContentPropertiesById"];
        /**
         * Update content property for blog post by id
         * @description Update a content property for blog post by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the blog post.
         */
        put: operations["updateBlogpostPropertyById"];
        post?: never;
        /**
         * Delete content property for blogpost by id
         * @description Deletes a content property for a blogpost by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the blog post.
         */
        delete: operations["deleteBlogpostPropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for blog post
         * @description Returns the permitted operations on specific blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the parent content of the blog post and its corresponding space.
         */
        get: operations["getBlogPostOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get blog post versions
         * @description Returns the versions of specific blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the blog post and its corresponding space.
         */
        get: operations["getBlogPostVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{blogpost-id}/versions/{version-number}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get version details for blog post version
         * @description Retrieves version details for the specified blog post and version number.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the blog post.
         */
        get: operations["getBlogPostVersionDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/content/convert-ids-to-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Convert content ids to content types
         * @description Converts a list of content ids into their associated content types. This is useful for users migrating from v1 to v2
         *     who may have stored just content ids without their associated type. This will return types as they should be used in v2.
         *     Notably, this will return `inline-comment` for inline comments and `footer-comment` for footer comments, which is distinct from them
         *     both being represented by `comment` in v1.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the requested content. Any content that the user does not have permission to view or does not exist will map to `null` in the response.
         */
        post: operations["convertContentIdsToContentTypes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get custom content by type
         * @description Returns all custom content for a given type. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
         */
        get: operations["getCustomContentByType"];
        put?: never;
        /**
         * Create custom content
         * @description Creates a new custom content in the given space, page, blogpost or other custom content.
         *
         *     Only one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is required in the request body.
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space. Permission to create custom content in the space.
         */
        post: operations["createCustomContent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get custom content by id
         * @description Returns a specific piece of custom content.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
         */
        get: operations["getCustomContentById"];
        /**
         * Update custom content
         * @description Update a custom content by id.
         *     At most one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is allowed in the request body.
         *     Note that if `spaceId` is specified, it must be the same as the `spaceId` used for creating the custom content
         *     as moving custom content to a different space is not supported.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space. Permission to update custom content in the space.
         */
        put: operations["updateCustomContent"];
        post?: never;
        /**
         * Delete custom content
         * @description Delete a custom content by id.
         *
         *     Deleting a custom content will either move it to the trash or permanently delete it (purge it), depending on the apiSupport.
         *     To permanently delete a **trashed** custom content, the endpoint must be called with the following param `purge=true`.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space.
         *     Permission to delete custom content in the space.
         *     Permission to administer the space (if attempting to purge).
         */
        delete: operations["deleteCustomContent"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{id}/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachments for custom content
         * @description Returns the attachments of specific custom content. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the custom content and its corresponding space.
         */
        get: operations["getCustomContentAttachments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{id}/footer-comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get custom content comments
         * @description Returns the comments of the specific custom content.
         *     The number of results is limited by the `limit` parameter and additional results (if available) will be available through
         *     the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content and its corresponding containers.
         */
        get: operations["getCustomContentComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{id}/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get labels for custom content
         * @description Returns the labels for a specific piece of custom content. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content and its corresponding space.
         *     Only labels that the user has permission to view will be returned.
         */
        get: operations["getCustomContentLabels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for custom content
         * @description Returns the permitted operations on specific custom content.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the parent content of the custom content and its corresponding space.
         */
        get: operations["getCustomContentOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{custom-content-id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for custom content
         * @description Retrieves Content Properties tied to a specified custom content.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content.
         */
        get: operations["getCustomContentContentProperties"];
        put?: never;
        /**
         * Create content property for custom content
         * @description Creates a new content property for a piece of custom content.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the custom content.
         */
        post: operations["createCustomContentProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{custom-content-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for custom content by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified custom content.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page.
         */
        get: operations["getCustomContentContentPropertiesById"];
        /**
         * Update content property for custom content by id
         * @description Update a content property for a piece of custom content by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the custom content.
         */
        put: operations["updateCustomContentPropertyById"];
        post?: never;
        /**
         * Delete content property for custom content by id
         * @description Deletes a content property for a piece of custom content by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the custom content.
         */
        delete: operations["deleteCustomContentPropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get labels
         * @description Returns all labels. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only labels that the user has permission to view will be returned.
         */
        get: operations["getLabels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/labels/{id}/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachments for label
         * @description Returns the attachments of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the attachment and its corresponding space.
         */
        get: operations["getLabelAttachments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/labels/{id}/blogposts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get blog posts for label
         * @description Returns the blogposts of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getLabelBlogPosts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/labels/{id}/pages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get pages for label
         * @description Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getLabelPages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get pages
         * @description Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only pages that the user has permission to view will be returned.
         */
        get: operations["getPages"];
        put?: never;
        /**
         * Create page
         * @description Creates a page in the space.
         *
         *     Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the corresponding space. Permission to create a page in the space.
         */
        post: operations["createPage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get page by id
         * @description Returns a specific page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page and its corresponding space.
         */
        get: operations["getPageById"];
        /**
         * Update page
         * @description Update a page by id.
         *
         *     When the "current" version is updated, the provided body content is considered as the latest version. This latest body content
         *     will be attempted to be merged into the draft version through a content reconciliation algorithm. If two versions are significantly diverged,
         *     the latest provided content may entirely override what was previously in the draft.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page and its corresponding space. Permission to update pages in the space.
         */
        put: operations["updatePage"];
        post?: never;
        /**
         * Delete page
         * @description Delete a page by id.
         *
         *     By default this will delete pages that are non-drafts. To delete a page that is a draft, the endpoint must be called on a
         *     draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.
         *
         *     Deleting a page moves the page to the trash, where it can be restored later. To permanently delete a page (or "purge" it),
         *     the endpoint must be called on a **trashed** page with the following param `purge=true`.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page and its corresponding space.
         *     Permission to delete pages in the space.
         *     Permission to administer the space (if attempting to purge).
         */
        delete: operations["deletePage"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get attachments for page
         * @description Returns the attachments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getPageAttachments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/custom-content": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get custom content by type in page
         * @description Returns all custom content for a given type within a given page. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content, the container of the custom content (page), and the corresponding space.
         */
        get: operations["getCustomContentByTypeInPage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get labels for page
         * @description Returns the labels of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         *     Only labels that the user has permission to view will be returned.
         */
        get: operations["getPageLabels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/likes/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get like count for page
         * @description Returns the count of likes of specific page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getPageLikeCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/likes/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get account IDs of likes for page
         * @description Returns the account IDs of likes of specific page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getPageLikeUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for page
         * @description Returns the permitted operations on specific page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the parent content of the page and its corresponding space.
         */
        get: operations["getPageOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{page-id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for page
         * @description Retrieves Content Properties tied to a specified page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page.
         */
        get: operations["getPageContentProperties"];
        put?: never;
        /**
         * Create content property for page
         * @description Creates a new content property for a page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the page.
         */
        post: operations["createPageProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{page-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for page by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page.
         */
        get: operations["getPageContentPropertiesById"];
        /**
         * Update content property for page by id
         * @description Update a content property for a page by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the page.
         */
        put: operations["updatePagePropertyById"];
        post?: never;
        /**
         * Delete content property for page by id
         * @description Deletes a content property for a page by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the page.
         */
        delete: operations["deletePagePropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/redact": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Redact Content in a Confluence Page
         * @description Redacts sensitive content in a Confluence page by replacing specified text ranges with redaction markers.
         *     Each redaction in the response includes a unique UUID for restoration (except code block redactions).
         *     The response metadata items maintain the same order as the input redaction pointers, and completely
         *     overlapping redactions are merged into a single redaction with one UUID.
         *
         *     **Note**: This endpoint requires **Atlassian Guard Premium**.
         *
         */
        post: operations["postRedactPage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/redact": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Redact Content in a Confluence Blog Post
         * @description Redacts sensitive content in a Confluence blog post by replacing specified text ranges with redaction markers.
         *     Each redaction in the response includes a unique UUID for restoration (except code block redactions).
         *     The response metadata items maintain the same order as the input redaction pointers, and completely
         *     overlapping redactions are merged into a single redaction with one UUID.
         *
         *     **Note**: This endpoint requires **Atlassian Guard Premium**.
         *
         */
        post: operations["postRedactBlog"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/title": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update page title
         * @description Updates the title of a specified page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page and its corresponding space. Permission to update pages in the space.
         */
        put: operations["updatePageTitle"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get page versions
         * @description Returns the versions of specific page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page and its corresponding space.
         */
        get: operations["getPageVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create whiteboard
         * @description Creates a whiteboard in the space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the corresponding space. Permission to create a whiteboard in the space.
         */
        post: operations["createWhiteboard"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get whiteboard by id
         * @description Returns a specific whiteboard.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the whiteboard and its corresponding space.
         */
        get: operations["getWhiteboardById"];
        put?: never;
        post?: never;
        /**
         * Delete whiteboard
         * @description Delete a whiteboard by id.
         *
         *     Deleting a whiteboard moves the whiteboard to the trash, where it can be restored later
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the whiteboard and its corresponding space.
         *     Permission to delete whiteboards in the space.
         */
        delete: operations["deleteWhiteboard"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for whiteboard
         * @description Retrieves Content Properties tied to a specified whiteboard.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the whiteboard.
         */
        get: operations["getWhiteboardContentProperties"];
        put?: never;
        /**
         * Create content property for whiteboard
         * @description Creates a new content property for a whiteboard.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the whiteboard.
         */
        post: operations["createWhiteboardProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{whiteboard-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for whiteboard by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified whiteboard.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the whiteboard.
         */
        get: operations["getWhiteboardContentPropertiesById"];
        /**
         * Update content property for whiteboard by id
         * @description Update a content property for a whiteboard by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the whiteboard.
         */
        put: operations["updateWhiteboardPropertyById"];
        post?: never;
        /**
         * Delete content property for whiteboard by id
         * @description Deletes a content property for a whiteboard by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the whiteboard.
         */
        delete: operations["deleteWhiteboardPropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for a whiteboard
         * @description Returns the permitted operations on specific whiteboard.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the whiteboard and its corresponding space.
         */
        get: operations["getWhiteboardOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{id}/direct-children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get direct children of a whiteboard
         * @description Returns all children for given whiteboard id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only content that the user has permission to view will be returned.
         */
        get: operations["getWhiteboardDirectChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{id}/descendants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get descendants of a whiteboard
         * @description Returns descendants in the content tree for a given whiteboard by ID in top-to-bottom order (that is, the highest descendant is the first
         *     item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
         *     of descendants to be fetched.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the whiteboard and its corresponding space
         */
        get: operations["getWhiteboardDescendants"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{id}/ancestors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all ancestors of whiteboard
         * @description Returns all ancestors for a given whiteboard by ID in top-to-bottom order (that is, the highest ancestor is the first
         *     item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available by calling this endpoint with the ID of first ancestor in the response payload.
         *
         *     This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
         *     as [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the whiteboard and its corresponding space
         */
        get: operations["getWhiteboardAncestors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create database
         * @description Creates a database in the space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the corresponding space. Permission to create a database in the space.
         */
        post: operations["createDatabase"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get database by id
         * @description Returns a specific database.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the database and its corresponding space.
         */
        get: operations["getDatabaseById"];
        put?: never;
        post?: never;
        /**
         * Delete database
         * @description Delete a database by id.
         *
         *     Deleting a database moves the database to the trash, where it can be restored later
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the database and its corresponding space.
         *     Permission to delete databases in the space.
         */
        delete: operations["deleteDatabase"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for database
         * @description Retrieves Content Properties tied to a specified database.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the database.
         */
        get: operations["getDatabaseContentProperties"];
        put?: never;
        /**
         * Create content property for database
         * @description Creates a new content property for a database.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the database.
         */
        post: operations["createDatabaseProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{database-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for database by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified database.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the database.
         */
        get: operations["getDatabaseContentPropertiesById"];
        /**
         * Update content property for database by id
         * @description Update a content property for a database by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the database.
         */
        put: operations["updateDatabasePropertyById"];
        post?: never;
        /**
         * Delete content property for database by id
         * @description Deletes a content property for a database by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the database.
         */
        delete: operations["deleteDatabasePropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for a database
         * @description Returns the permitted operations on specific database.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the database and its corresponding space.
         */
        get: operations["getDatabaseOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{id}/direct-children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get direct children of a database
         * @description Returns all children for given database id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only content that the user has permission to view will be returned.
         */
        get: operations["getDatabaseDirectChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{id}/descendants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get descendants of a database
         * @description Returns descendants in the content tree for a given database by ID in top-to-bottom order (that is, the highest descendant is the first
         *     item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
         *     of descendants to be fetched.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the database and its corresponding space
         */
        get: operations["getDatabaseDescendants"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{id}/ancestors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all ancestors of database
         * @description Returns all ancestors for a given database by ID in top-to-bottom order (that is, the highest ancestor is the first
         *     item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available by calling this endpoint with the ID of first ancestor in the response payload.
         *
         *     This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
         *     as [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the database and its corresponding space
         */
        get: operations["getDatabaseAncestors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Smart Link in the content tree
         * @description Creates a Smart Link in the content tree in the space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the corresponding space. Permission to create a Smart Link in the content tree in the space.
         */
        post: operations["createSmartLink"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeds/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Smart Link in the content tree by id
         * @description Returns a specific Smart Link in the content tree.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the Smart Link in the content tree and its corresponding space.
         */
        get: operations["getSmartLinkById"];
        put?: never;
        post?: never;
        /**
         * Delete Smart Link in the content tree
         * @description Delete a Smart Link in the content tree by id.
         *
         *     Deleting a Smart Link in the content tree moves the Smart Link to the trash, where it can be restored later
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the Smart Link in the content tree and its corresponding space.
         *     Permission to delete Smart Links in the content tree in the space.
         */
        delete: operations["deleteSmartLink"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeds/{id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for Smart Link in the content tree
         * @description Retrieves Content Properties tied to a specified Smart Link in the content tree.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the Smart Link in the content tree.
         */
        get: operations["getSmartLinkContentProperties"];
        put?: never;
        /**
         * Create content property for Smart Link in the content tree
         * @description Creates a new content property for a Smart Link in the content tree.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the Smart Link in the content tree.
         */
        post: operations["createSmartLinkProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeds/{embed-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for Smart Link in the content tree by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified Smart Link in the content tree.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the Smart Link in the content tree.
         */
        get: operations["getSmartLinkContentPropertiesById"];
        /**
         * Update content property for Smart Link in the content tree by id
         * @description Update a content property for a Smart Link in the content tree by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the Smart Link in the content tree.
         */
        put: operations["updateSmartLinkPropertyById"];
        post?: never;
        /**
         * Delete content property for Smart Link in the content tree by id
         * @description Deletes a content property for a Smart Link in the content tree by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the Smart Link in the content tree.
         */
        delete: operations["deleteSmartLinkPropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeds/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for a Smart Link in the content tree
         * @description Returns the permitted operations on specific Smart Link in the content tree.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the Smart Link in the content tree and its corresponding space.
         */
        get: operations["getSmartLinkOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeds/{id}/direct-children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get direct children of a Smart Link
         * @description Returns all children for given smart link id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only content that the user has permission to view will be returned.
         */
        get: operations["getSmartLinkDirectChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeds/{id}/descendants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get descendants of a smart link
         * @description Returns descendants in the content tree for a given smart link by ID in top-to-bottom order (that is, the highest descendant is the first
         *     item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
         *     of descendants to be fetched.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *
         *     This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the smart link and its corresponding space
         */
        get: operations["getSmartLinkDescendants"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/embeds/{id}/ancestors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all ancestors of Smart Link in content tree
         * @description Returns all ancestors for a given Smart Link in the content tree by ID in top-to-bottom order (that is, the highest ancestor is
         *     the first item in the response payload). The number of results is limited by the `limit` parameter and additional results
         *     (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.
         *
         *     This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
         *     as [Get Smart Link in the content tree by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the Smart Link in the content tree and its corresponding space
         */
        get: operations["getSmartLinkAncestors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create folder
         * @description Creates a folder in the space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the corresponding space. Permission to create a folder in the space.
         */
        post: operations["createFolder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get folder by id
         * @description Returns a specific folder.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the folder and its corresponding space.
         */
        get: operations["getFolderById"];
        put?: never;
        post?: never;
        /**
         * Delete folder
         * @description Delete a folder by id.
         *
         *     Deleting a folder moves the folder to the trash, where it can be restored later
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the folder and its corresponding space.
         *     Permission to delete folders in the space.
         */
        delete: operations["deleteFolder"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders/{id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for folder
         * @description Retrieves Content Properties tied to a specified folder.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the folder.
         */
        get: operations["getFolderContentProperties"];
        put?: never;
        /**
         * Create content property for folder
         * @description Creates a new content property for a folder.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the folder.
         */
        post: operations["createFolderProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders/{folder-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for folder by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified folder.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the folder.
         */
        get: operations["getFolderContentPropertiesById"];
        /**
         * Update content property for folder by id
         * @description Update a content property for a folder by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the folder.
         */
        put: operations["updateFolderPropertyById"];
        post?: never;
        /**
         * Delete content property for folder by id
         * @description Deletes a content property for a folder by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the folder.
         */
        delete: operations["deleteFolderPropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for a folder
         * @description Returns the permitted operations on specific folder.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the folder and its corresponding space.
         */
        get: operations["getFolderOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders/{id}/direct-children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get direct children of a folder
         * @description Returns all children for given folder id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only content that the user has permission to view will be returned.
         */
        get: operations["getFolderDirectChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders/{id}/descendants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get descendants of folder
         * @description Returns descendants in the content tree for a given folder by ID in top-to-bottom order (that is, the highest descendant is the first
         *     item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
         *     of descendants to be fetched.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the  and its corresponding space
         */
        get: operations["getFolderDescendants"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/folders/{id}/ancestors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all ancestors of folder
         * @description Returns all ancestors for a given folder by ID in top-to-bottom order (that is, the highest ancestor is
         *     the first item in the response payload). The number of results is limited by the `limit` parameter and additional results
         *     (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.
         *
         *     This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
         *     as [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-folders-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the folder and its corresponding space
         */
        get: operations["getFolderAncestors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{page-id}/versions/{version-number}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get version details for page version
         * @description Retrieves version details for the specified page and version number.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page.
         */
        get: operations["getPageVersionDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{custom-content-id}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get custom content versions
         * @description Returns the versions of specific custom content.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content and its corresponding page and space.
         */
        get: operations["getCustomContentVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{custom-content-id}/versions/{version-number}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get version details for custom content version
         * @description Retrieves version details for the specified custom content and version number.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the page.
         */
        get: operations["getCustomContentVersionDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get spaces
         * @description Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
         *     additional results (if available) will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only spaces that the user has permission to view will be returned.
         */
        get: operations["getSpaces"];
        put?: never;
        /**
         * Create space
         * @description Creates a Space as specified in the payload.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to create spaces.
         */
        post: operations["createSpace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get space by id
         * @description Returns a specific space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the space.
         */
        get: operations["getSpaceById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/blogposts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get blog posts in space
         * @description Returns all blog posts in a space. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission) and view the space.
         *     Only blog posts that the user has permission to view will be returned.
         */
        get: operations["getBlogPostsInSpace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get labels for space
         * @description Returns the labels of specific space. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the space.
         *     Only labels that the user has permission to view will be returned.
         */
        get: operations["getSpaceLabels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/content/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get labels for space content
         * @description Returns the labels of space content (pages, blogposts etc). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the space.
         *     Only labels that the user has permission to view will be returned.
         */
        get: operations["getSpaceContentLabels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/custom-content": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get custom content by type in space
         * @description Returns all custom content for a given type within a given space. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the custom content and the corresponding space.
         */
        get: operations["getCustomContentByTypeInSpace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for space
         * @description Returns the permitted operations on specific space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the corresponding space.
         */
        get: operations["getSpaceOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/pages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get pages in space
         * @description Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
         *     Only pages that the user has permission to view will be returned.
         */
        get: operations["getPagesInSpace"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{space-id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get space properties in space
         * @description Returns all properties for the given space. Space properties are a key-value storage associated with a space.
         *     The limit parameter specifies the maximum number of results returned in a single response. Use the `link` response header
         *     to paginate through additional results.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
         */
        get: operations["getSpaceProperties"];
        put?: never;
        /**
         * Create space property in space
         * @description Creates a new space property.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
         */
        post: operations["createSpaceProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{space-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get space property by id
         * @description Retrieve a space property by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
         */
        get: operations["getSpacePropertyById"];
        /**
         * Update space property by id
         * @description Update a space property by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
         */
        put: operations["updateSpacePropertyById"];
        post?: never;
        /**
         * Delete space property by id
         * @description Deletes a space property by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
         */
        delete: operations["deleteSpacePropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get space permissions assignments
         * @description Returns space permission assignments for a specific space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the space.
         */
        get: operations["getSpacePermissionsAssignments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/space-permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get available space permissions
         * @description Retrieves the available space permissions.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site.
         */
        get: operations["getAvailableSpacePermissions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/space-roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get available space roles
         * @description Retrieves the available space roles.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site; if requesting a certain space's roles, permission to view the space.
         */
        get: operations["getAvailableSpaceRoles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/space-roles/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get space role by ID
         * @description Retrieves the space role by ID.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site.
         */
        get: operations["getSpaceRolesById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/role-assignments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get space role assignments
         * @description Retrieves the space role assignments.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the space.
         */
        get: operations["getSpaceRoleAssignments"];
        put?: never;
        /**
         * Set space role assignments
         * @description Sets space role assignments as specified in the payload.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to manage roles in the space.
         */
        post: operations["setSpaceRoleAssignments"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/footer-comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get footer comments for page
         * @description Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getPageFooterComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/inline-comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get inline comments for page
         * @description Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getPageInlineComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/footer-comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get footer comments for blog post
         * @description Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the blog post and its corresponding space.
         */
        get: operations["getBlogPostFooterComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/inline-comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get inline comments for blog post
         * @description Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the blog post and its corresponding space.
         */
        get: operations["getBlogPostInlineComments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/footer-comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get footer comments
         * @description Returns all footer comments. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the container and its corresponding space.
         */
        get: operations["getFooterComments"];
        put?: never;
        /**
         * Create footer comment
         * @description Create a footer comment.
         *
         *     The footer comment can be made against several locations:
         *     - at the top level (specifying pageId or blogPostId in the request body)
         *     - as a reply (specifying parentCommentId in the request body)
         *     - against an attachment (note: this is different than the comments added via the attachment properties page on the UI, which are referred to as version comments)
         *     - against a custom content
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
         */
        post: operations["createFooterComment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/footer-comments/{comment-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get footer comment by id
         * @description Retrieves a footer comment by id
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the container and its corresponding space.
         */
        get: operations["getFooterCommentById"];
        /**
         * Update footer comment
         * @description Update a footer comment. This can be used to update the body text of a comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
         */
        put: operations["updateFooterComment"];
        post?: never;
        /**
         * Delete footer comment
         * @description Deletes a footer comment. This is a permanent deletion and cannot be reverted.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
         */
        delete: operations["deleteFooterComment"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/footer-comments/{id}/children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get children footer comments
         * @description Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getFooterCommentChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/footer-comments/{id}/likes/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get like count for footer comment
         * @description Returns the count of likes of specific footer comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page/blogpost and its corresponding space.
         */
        get: operations["getFooterLikeCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/footer-comments/{id}/likes/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get account IDs of likes for footer comment
         * @description Returns the account IDs of likes of specific footer comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page/blogpost and its corresponding space.
         */
        get: operations["getFooterLikeUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/footer-comments/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for footer comment
         * @description Returns the permitted operations on specific footer comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the parent content of the footer comment and its corresponding space.
         */
        get: operations["getFooterCommentOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/footer-comments/{id}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get footer comment versions
         * @description Retrieves the versions of the specified footer comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blog post and its corresponding space.
         */
        get: operations["getFooterCommentVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/footer-comments/{id}/versions/{version-number}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get version details for footer comment version
         * @description Retrieves version details for the specified footer comment version.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blog post and its corresponding space.
         */
        get: operations["getFooterCommentVersionDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inline-comments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get inline comments
         * @description Returns all inline comments. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getInlineComments"];
        put?: never;
        /**
         * Create inline comment
         * @description Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body)
         *     or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the
         *     request body is used to select the text the inline comment should be tied to. This is what determines the text
         *     highlighting when viewing a page in Confluence.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
         */
        post: operations["createInlineComment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inline-comments/{comment-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get inline comment by id
         * @description Retrieves an inline comment by id
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space.
         */
        get: operations["getInlineCommentById"];
        /**
         * Update inline comment
         * @description Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
         */
        put: operations["updateInlineComment"];
        post?: never;
        /**
         * Delete inline comment
         * @description Deletes an inline comment. This is a permanent deletion and cannot be reverted.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
         */
        delete: operations["deleteInlineComment"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inline-comments/{id}/children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get children inline comments
         * @description Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page and its corresponding space.
         */
        get: operations["getInlineCommentChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inline-comments/{id}/likes/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get like count for inline comment
         * @description Returns the count of likes of specific inline comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page/blogpost and its corresponding space.
         */
        get: operations["getInlineLikeCount"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inline-comments/{id}/likes/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get account IDs of likes for inline comment
         * @description Returns the account IDs of likes of specific inline comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page/blogpost and its corresponding space.
         */
        get: operations["getInlineLikeUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inline-comments/{id}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get permitted operations for inline comment
         * @description Returns the permitted operations on specific inline comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the parent content of the inline comment and its corresponding space.
         */
        get: operations["getInlineCommentOperations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inline-comments/{id}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get inline comment versions
         * @description Retrieves the versions of the specified inline comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blog post and its corresponding space.
         */
        get: operations["getInlineCommentVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inline-comments/{id}/versions/{version-number}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get version details for inline comment version
         * @description Retrieves version details for the specified inline comment version.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the content of the page or blog post and its corresponding space.
         */
        get: operations["getInlineCommentVersionDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comments/{comment-id}/properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content properties for comment
         * @description Retrieves Content Properties attached to a specified comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the comment.
         */
        get: operations["getCommentContentProperties"];
        put?: never;
        /**
         * Create content property for comment
         * @description Creates a new content property for a comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to update the comment.
         */
        post: operations["createCommentProperty"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comments/{comment-id}/properties/{property-id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get content property for comment by id
         * @description Retrieves a specific Content Property by ID that is attached to a specified comment.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the comment.
         */
        get: operations["getCommentContentPropertiesById"];
        /**
         * Update content property for comment by id
         * @description Update a content property for a comment by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the comment.
         */
        put: operations["updateCommentPropertyById"];
        post?: never;
        /**
         * Delete content property for comment by id
         * @description Deletes a content property for a comment by its id.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the comment.
         */
        delete: operations["deleteCommentPropertyById"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tasks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get tasks
         * @description Returns all tasks. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only tasks that the user has permission to view will be returned.
         */
        get: operations["getTasks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tasks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get task by id
         * @description Returns a specific task.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to view the containing page or blog post and its corresponding space.
         */
        get: operations["getTaskById"];
        /**
         * Update task
         * @description Update a task by id. This endpoint currently only supports updating task status.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to edit the containing page or blog post and view its corresponding space.
         */
        put: operations["updateTask"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get child pages
         * @deprecated
         * @description Returns all child pages for given page id. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only pages that the user has permission to view will be returned.
         */
        get: operations["getChildPages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom-content/{id}/children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get child custom content
         * @description Returns all child custom content for given custom content id. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only custom content that the user has permission to view will be returned.
         */
        get: operations["getChildCustomContent"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/direct-children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get direct children of a page
         * @description Returns all children for given page id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available through the `next` URL present in the `Link` response header.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only content that the user has permission to view will be returned.
         */
        get: operations["getPageDirectChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/ancestors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all ancestors of page
         * @description Returns all ancestors for a given page by ID in top-to-bottom order (that is, the highest ancestor is the first
         *     item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available by calling this endpoint with the ID of first ancestor in the response payload.
         *
         *     This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
         *     as [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         */
        get: operations["getPageAncestors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/descendants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get descendants of page
         * @description Returns descendants in the content tree for a given page by ID in top-to-bottom order (that is, the highest descendant is the first
         *     item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
         *     will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
         *     of descendants to be fetched.
         *
         *     The following types of content will be returned:
         *     - Database
         *     - Embed
         *     - Folder
         *     - Page
         *     - Whiteboard
         *
         *     This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
         *     as:
         *
         *     - [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
         *     - [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
         *     - [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
         *     - [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
         *     - [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Permission to view the page and its corresponding space
         */
        get: operations["getPageDescendants"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users-bulk": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create bulk user lookup using ids
         * @description Returns user details for the ids provided in the request body.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         *     The user must be able to view user profiles in the Confluence site.
         */
        post: operations["createBulkUserLookup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/access/check-access-by-email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Check site access for a list of emails
         * @description Returns the list of emails from the input list that do not have access to site.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         */
        post: operations["checkAccessByEmail"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/user/access/invite-by-email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Invite a list of emails to the site
         * @description Invite a list of emails to the site.
         *
         *     Ignores all invalid emails and no action is taken for the emails that already have access to the site.
         *
         *     <b>NOTE:</b> This API is asynchronous and may take some time to complete.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Permission to access the Confluence site ('Can use' global permission).
         */
        post: operations["inviteByEmail"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data-policies/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get data policy metadata for the workspace
         * @description Returns data policy metadata for the workspace.
         *
         *     **[Permissions](#permissions) required:**
         *     Only apps can make this request.
         *     Permission to access the Confluence site ('Can use' global permission).
         */
        get: operations["getDataPolicyMetadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/data-policies/spaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get spaces with data policies
         * @description Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
         *     additional results (if available) will be available through the `next` URL present in the `Link` response header.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     Only apps can make this request.
         *     Permission to access the Confluence site ('Can use' global permission).
         *     Only spaces that the app has permission to view will be returned.
         */
        get: operations["getDataPolicySpaces"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/classification-levels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get list of classification levels
         * @description Returns a list of [classification levels](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     available.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission).
         */
        get: operations["getClassificationLevels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/spaces/{id}/classification-level/default": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get space default classification level
         * @description Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/)
         *     for a specific space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the space.
         */
        get: operations["getSpaceDefaultClassificationLevel"];
        /**
         * Update space default classification level
         * @description Update the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/)
         *     for a specific space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
         */
        put: operations["putSpaceDefaultClassificationLevel"];
        post?: never;
        /**
         * Delete space default classification level
         * @description Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/)
         *     for a specific space.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
         */
        delete: operations["deleteSpaceDefaultClassificationLevel"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/classification-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get page classification level
         * @description Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the page.
         *     'Permission to edit the page is required if trying to view classification level for a draft.
         */
        get: operations["getPageClassificationLevel"];
        /**
         * Update page classification level
         * @description Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific page.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to edit the page.
         */
        put: operations["putPageClassificationLevel"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/pages/{id}/classification-level/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset page classification level
         * @description Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific page for the space
         *     [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the page.
         */
        post: operations["postPageClassificationLevel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/classification-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get blog post classification level
         * @description Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the blog post.
         *     'Permission to edit the blog post is required if trying to view classification level for a draft.
         */
        get: operations["getBlogPostClassificationLevel"];
        /**
         * Update blog post classification level
         * @description Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific blog post.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to edit the blog post.
         */
        put: operations["putBlogPostClassificationLevel"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blogposts/{id}/classification-level/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset blog post classification level
         * @description Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific blog post for the space
         *     [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the blog post.
         */
        post: operations["postBlogPostClassificationLevel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{id}/classification-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get whiteboard classification level
         * @description Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific whiteboard.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the whiteboard.
         */
        get: operations["getWhiteboardClassificationLevel"];
        /**
         * Update whiteboard classification level
         * @description Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific whiteboard.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to edit the whiteboard.
         */
        put: operations["putWhiteboardClassificationLevel"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/whiteboards/{id}/classification-level/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset whiteboard classification level
         * @description Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific whiteboard for the space
         *     [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the whiteboard.
         */
        post: operations["postWhiteboardClassificationLevel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{id}/classification-level": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get database classification level
         * @description Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific database.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the database.
         */
        get: operations["getDatabaseClassificationLevel"];
        /**
         * Update database classification level
         * @description Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific database.
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to edit the database.
         */
        put: operations["putDatabaseClassificationLevel"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/databases/{id}/classification-level/reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reset database classification level
         * @description Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
         *     for a specific database for the space
         *     [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
         *
         *     **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
         *     'Permission to access the Confluence site ('Can use' global permission) and permission to view the database.
         */
        post: operations["postDatabaseClassificationLevel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/app/properties/{propertyKey}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Create or update a Forge app property.
         * @description Creates or updates a Forge app property.
         */
        put: operations["putForgeAppProperty"];
        post?: never;
        /**
         * Deletes a Forge app property.
         * @description Deletes a Forge app property.
         */
        delete: operations["deleteForgeAppProperty"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AdminKeyResponse: {
            /** @description User identifier. */
            accountId?: string;
            /**
             * Format: date-time
             * @description Timestamp in UTC that represents when the admin key will expire. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            expirationTime?: string;
        };
        AttachmentSingle: {
            /** @description ID of the attachment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /**
             * Format: date-time
             * @description Date and time when the attachment was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description ID of the containing page.
             *
             *     Note: This is only returned if the attachment has a container that is a page. */
            pageId?: string;
            /** @description ID of the containing blog post.
             *
             *     Note: This is only returned if the attachment has a container that is a blog post. */
            blogPostId?: string;
            /** @description ID of the containing custom content.
             *
             *     Note: This is only returned if the attachment has a container that is custom content. */
            customContentId?: string;
            /** @description Media Type for the attachment. */
            mediaType?: string;
            /** @description Media Type description for the attachment. */
            mediaTypeDescription?: string;
            /** @description Comment for the attachment. */
            comment?: string;
            /** @description File ID of the attachment. This is the ID referenced in `atlas_doc_format` bodies and is distinct from the attachment ID. */
            fileId?: string;
            /**
             * Format: int64
             * @description File size of the attachment.
             */
            fileSize?: number;
            /** @description WebUI link of the attachment. */
            webuiLink?: string;
            /** @description Download link of the attachment. */
            downloadLink?: string;
            version?: components["schemas"]["Version"];
            labels?: {
                results?: components["schemas"]["Label"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            properties?: {
                results?: components["schemas"]["ContentProperty"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            operations?: {
                results?: components["schemas"]["Operation"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            versions?: {
                results?: components["schemas"]["Version"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            _links?: components["schemas"]["AttachmentLinks"];
        };
        AttachmentBulk: {
            /** @description ID of the attachment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /**
             * Format: date-time
             * @description Date and time when the attachment was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description ID of the containing page.
             *
             *     Note: This is only returned if the attachment has a container that is a page. */
            pageId?: string;
            /** @description ID of the containing blog post.
             *
             *     Note: This is only returned if the attachment has a container that is a blog post. */
            blogPostId?: string;
            /** @description ID of the containing custom content.
             *
             *     Note: This is only returned if the attachment has a container that is custom content. */
            customContentId?: string;
            /** @description Media Type for the attachment. */
            mediaType?: string;
            /** @description Media Type description for the attachment. */
            mediaTypeDescription?: string;
            /** @description Comment for the attachment. */
            comment?: string;
            /** @description File ID of the attachment. This is the ID referenced in `atlas_doc_format` bodies and is distinct from the attachment ID. */
            fileId?: string;
            /**
             * Format: int64
             * @description File size of the attachment.
             */
            fileSize?: number;
            /** @description WebUI link of the attachment. */
            webuiLink?: string;
            /** @description Download link of the attachment. */
            downloadLink?: string;
            version?: components["schemas"]["Version"];
            _links?: components["schemas"]["AttachmentLinks"];
        };
        BlogPostSingle: {
            /** @description ID of the blog post. */
            id?: string;
            status?: components["schemas"]["BlogPostContentStatus"];
            /** @description Title of the blog post. */
            title?: string;
            /** @description ID of the space the blog post is in. */
            spaceId?: string;
            /** @description The account ID of the user who created this blog post originally. */
            authorId?: string;
            /**
             * Format: date-time
             * @description Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodySingle"];
            labels?: {
                results?: components["schemas"]["Label"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            properties?: {
                results?: components["schemas"]["ContentProperty"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            operations?: {
                results?: components["schemas"]["Operation"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            likes?: {
                results?: components["schemas"]["Like"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            versions?: {
                results?: components["schemas"]["Version"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            /** @description Whether the blog post has been favorited by the current user. */
            isFavoritedByCurrentUser?: boolean;
            _links?: components["schemas"]["AbstractPageLinks"];
        };
        BlogPostBulk: {
            /** @description ID of the blog post. */
            id?: string;
            status?: components["schemas"]["BlogPostContentStatus"];
            /** @description Title of the blog post. */
            title?: string;
            /** @description ID of the space the blog post is in. */
            spaceId?: string;
            /** @description The account ID of the user who created this blog post originally. */
            authorId?: string;
            /**
             * Format: date-time
             * @description Date and time when the blog post was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodyBulk"];
            _links?: components["schemas"]["AbstractPageLinks"];
        };
        /** @description Contains fields for each representation type requested. */
        TaskBodySingle: {
            storage?: components["schemas"]["BodyType"];
            atlas_doc_format?: components["schemas"]["BodyType"];
        };
        /** @description Contains fields for each representation type requested. */
        BodySingle: {
            storage?: components["schemas"]["BodyType"];
            atlas_doc_format?: components["schemas"]["BodyType"];
            view?: components["schemas"]["BodyType"];
        };
        /** @description Contains fields for each representation type requested. */
        BodyBulk: {
            storage?: components["schemas"]["BodyType"];
            atlas_doc_format?: components["schemas"]["BodyType"];
        };
        BodyType: {
            /** @description Type of content representation used for the value field. */
            representation?: string;
            /** @description Body of the content, in the format found in the representation field. */
            value?: string;
        };
        /**
         * @description The primary formats a body can be represented as. A subset of BodyRepresentation. These formats are the only allowed formats in certain use cases.
         * @enum {string}
         */
        PrimaryBodyRepresentation: "storage" | "atlas_doc_format";
        /**
         * @description The primary formats a body can be represented as. A subset of BodyRepresentation. These formats are the only allowed formats in certain use cases.
         * @enum {string}
         */
        PrimaryBodyRepresentationSingle: "storage" | "atlas_doc_format" | "view" | "export_view" | "anonymous_export_view" | "styled_view" | "editor";
        /**
         * @description The formats a custom content body can be represented as. A subset of BodyRepresentation.
         * @enum {string}
         */
        CustomContentBodyRepresentation: "raw" | "storage" | "atlas_doc_format";
        /**
         * @description The formats a custom content body can be represented as. A subset of BodyRepresentation.
         * @enum {string}
         */
        CustomContentBodyRepresentationSingle: "raw" | "storage" | "atlas_doc_format" | "view" | "export_view" | "anonymous_export_view";
        /**
         * @description The formats a space description can be represented as. A subset of BodyRepresentation.
         * @enum {string}
         */
        SpaceDescriptionBodyRepresentation: "plain" | "view";
        ContentIdToContentTypeResponse: {
            /** @description JSON object containing all requested content ids as keys and their associated content types as the values.
             *     Duplicate content ids in the request will be returned under a single key in the response. For built-in content
             *     types, the enumerations are as specified. Custom content ids will be mapped to their associated type. */
            results?: {
                [key: string]: ("page" | "blogpost" | "attachment" | "footer-comment" | "inline-comment") | string;
            };
        };
        /**
         * @description The status of the content.
         * @enum {string}
         */
        ContentStatus: "current" | "draft" | "archived" | "historical" | "trashed" | "deleted" | "any";
        /**
         * @description The status of the content.
         * @enum {string}
         */
        BlogPostContentStatus: "current" | "draft" | "historical" | "trashed" | "deleted" | "any";
        /**
         * @description The status of the content.
         * @enum {string}
         */
        OnlyArchivedAndCurrentContentStatus: "current" | "archived";
        ContentProperty: {
            /** @description ID of the property */
            id?: string;
            /** @description Key of the property */
            key?: string;
            /** @description Value of the property. Must be a valid JSON value. */
            value?: unknown;
            version?: components["schemas"]["Version"];
        };
        ContentPropertyCreateRequest: {
            /** @description Key of the content property */
            key?: string;
            /** @description Value of the content property. */
            value?: unknown;
        };
        ContentPropertyUpdateRequest: {
            /** @description Key of the content property */
            key?: string;
            /** @description Value of the content property. */
            value?: unknown;
            /** @description New version number and associated message */
            version?: {
                /**
                 * Format: int32
                 * @description Version number of the new version. Should be 1 more than the current version number.
                 */
                number?: number;
                /** @description Message to be associated with the new version. */
                message?: string;
            };
        };
        CustomContentSingle: {
            /** @description ID of the custom content. */
            id?: string;
            /** @description The type of custom content. */
            type?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the custom content. */
            title?: string;
            /** @description ID of the space the custom content is in.
             *
             *     Note: This is always returned, regardless of if the custom content has a container that is a space. */
            spaceId?: string;
            /** @description ID of the containing page.
             *
             *     Note: This is only returned if the custom content has a container that is a page. */
            pageId?: string;
            /** @description ID of the containing blog post.
             *
             *     Note: This is only returned if the custom content has a container that is a blog post. */
            blogPostId?: string;
            /** @description ID of the containing custom content.
             *
             *     Note: This is only returned if the custom content has a container that is custom content. */
            customContentId?: string;
            /** @description The account ID of the user who created this custom content originally. */
            authorId?: string;
            /**
             * Format: date-time
             * @description Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            labels?: {
                results?: components["schemas"]["Label"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            properties?: {
                results?: components["schemas"]["ContentProperty"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            operations?: {
                results?: components["schemas"]["Operation"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            versions?: {
                results?: components["schemas"]["Version"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            body?: components["schemas"]["CustomContentBodySingle"];
            _links?: components["schemas"]["CustomContentLinks"];
        };
        CustomContentBulk: {
            /** @description ID of the custom content. */
            id?: string;
            /** @description The type of custom content. */
            type?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the custom content. */
            title?: string;
            /** @description ID of the space the custom content is in.
             *
             *     Note: This is always returned, regardless of if the custom content has a container that is a space. */
            spaceId?: string;
            /** @description ID of the containing page.
             *
             *     Note: This is only returned if the custom content has a container that is a page. */
            pageId?: string;
            /** @description ID of the containing blog post.
             *
             *     Note: This is only returned if the custom content has a container that is a blog post. */
            blogPostId?: string;
            /** @description ID of the containing custom content.
             *
             *     Note: This is only returned if the custom content has a container that is custom content. */
            customContentId?: string;
            /** @description The account ID of the user who created this custom content originally. */
            authorId?: string;
            /**
             * Format: date-time
             * @description Date and time when the custom content was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["CustomContentBodyBulk"];
            _links?: components["schemas"]["CustomContentLinks"];
        };
        /** @description Contains fields for each representation type requested. */
        CustomContentBodySingle: {
            raw?: components["schemas"]["BodyType"];
            storage?: components["schemas"]["BodyType"];
            atlas_doc_format?: components["schemas"]["BodyType"];
            view?: components["schemas"]["BodyType"];
        };
        /** @description Contains fields for each representation type requested. */
        CustomContentBodyBulk: {
            raw?: components["schemas"]["BodyType"];
            storage?: components["schemas"]["BodyType"];
            atlas_doc_format?: components["schemas"]["BodyType"];
        };
        DetailedVersion: {
            /**
             * Format: int32
             * @description The current version number.
             */
            number?: number;
            /** @description The account ID of the user who created this version. */
            authorId?: string;
            /** @description Message associated with the current version. */
            message?: string;
            /**
             * Format: date-time
             * @description Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions. */
            minorEdit?: boolean;
            /** @description Describes if the content type is modified in this version (e.g. page to blog) */
            contentTypeModified?: boolean;
            /** @description The account IDs of users that collaborated on this version. */
            collaborators?: string[];
            /**
             * Format: int32
             * @description The version number of the version prior to this current content update.
             */
            prevVersion?: number;
            /**
             * Format: int32
             * @description The version number of the version after this current content update.
             */
            nextVersion?: number;
        };
        Label: {
            /** @description ID of the label. */
            id?: string;
            /** @description Name of the label. */
            name?: string;
            /** @description Prefix of the label. */
            prefix?: string;
        };
        Like: {
            /** @description Account ID. */
            accountId?: string;
        };
        Operation: {
            /** @description The type of operation. */
            operation?: string;
            /** @description The type of entity the operation type targets. */
            targetType?: string;
        };
        /** @description The list of operations permitted on entity. */
        PermittedOperationsResponse: {
            operations?: components["schemas"]["Operation"][];
        };
        PageSingle: {
            /** @description ID of the page. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the page. */
            title?: string;
            /** @description ID of the space the page is in. */
            spaceId?: string;
            /** @description ID of the parent page, or null if there is no parent page. */
            parentId?: string;
            parentType?: components["schemas"]["ParentContentType"];
            /**
             * Format: int32
             * @description Position of child page within the given parent page tree.
             */
            position?: number | null;
            /** @description The account ID of the user who created this page originally. */
            authorId?: string;
            /** @description The account ID of the user who owns this page. */
            ownerId?: string | null;
            /** @description The account ID of the user who owned this page previously, or null if there is no previous owner. */
            lastOwnerId?: string | null;
            /**
             * Format: date-time
             * @description Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodySingle"];
            labels?: {
                results?: components["schemas"]["Label"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            properties?: {
                results?: components["schemas"]["ContentProperty"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            operations?: {
                results?: components["schemas"]["Operation"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            likes?: {
                results?: components["schemas"]["Like"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            versions?: {
                results?: components["schemas"]["Version"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            /** @description Whether the page has been favorited by the current user. */
            isFavoritedByCurrentUser?: boolean;
            _links?: components["schemas"]["AbstractPageLinks"];
        };
        PageBulk: {
            /** @description ID of the page. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the page. */
            title?: string;
            /** @description ID of the space the page is in. */
            spaceId?: string;
            /** @description ID of the parent page, or null if there is no parent page. */
            parentId?: string;
            parentType?: components["schemas"]["ParentContentType"];
            /**
             * Format: int32
             * @description Position of child page within the given parent page tree.
             */
            position?: number | null;
            /** @description The account ID of the user who created this page originally. */
            authorId?: string;
            /** @description The account ID of the user who owns this page. */
            ownerId?: string | null;
            /** @description The account ID of the user who owned this page previously, or null if there is no previous owner. */
            lastOwnerId?: string | null;
            /** @description The subtype of the page. */
            subtype?: string | null;
            /**
             * Format: date-time
             * @description Date and time when the page was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodyBulk"];
            _links?: components["schemas"]["AbstractPageLinks"];
        };
        /**
         * @description Content type of the parent, or null if there is no parent.
         * @enum {string}
         */
        ParentContentType: "page" | "whiteboard" | "database" | "embed" | "folder";
        PageBodyWrite: {
            /**
             * @description Type of content representation used for the value field.
             * @enum {string}
             */
            representation?: "storage" | "atlas_doc_format" | "wiki";
            /** @description Body of the page, in the format found in the representation field. */
            value?: string;
        };
        /** @description Body of the page. Only one body format should be specified as the property
         *     for this object, e.g. `storage`. */
        PageNestedBodyWrite: {
            storage?: components["schemas"]["PageBodyWrite"];
            atlas_doc_format?: components["schemas"]["PageBodyWrite"];
            wiki?: components["schemas"]["PageBodyWrite"];
        };
        BlogPostBodyWrite: {
            /**
             * @description Type of content representation used for the value field.
             * @enum {string}
             */
            representation?: "storage" | "atlas_doc_format" | "wiki";
            /** @description Body of the blog post, in the format found in the representation field. */
            value?: string;
        };
        /** @description Body of the blog post. Only one body format should be specified as the property
         *     for this object, e.g. `storage`. */
        BlogPostNestedBodyWrite: {
            storage?: components["schemas"]["BlogPostBodyWrite"];
            atlas_doc_format?: components["schemas"]["BlogPostBodyWrite"];
            wiki?: components["schemas"]["BlogPostBodyWrite"];
        };
        CommentBodyWrite: {
            /**
             * @description Type of content representation used for the value field.
             * @enum {string}
             */
            representation?: "storage" | "atlas_doc_format" | "wiki";
            /** @description Body of the comment, in the format found in the representation field. */
            value?: string;
        };
        /** @description Body of the comment. Only one body format should be specified as the property
         *     for this object, e.g. `storage`. */
        CommentNestedBodyWrite: {
            storage?: components["schemas"]["CommentBodyWrite"];
            atlas_doc_format?: components["schemas"]["CommentBodyWrite"];
            wiki?: components["schemas"]["CommentBodyWrite"];
        };
        CustomContentBodyWrite: {
            /**
             * @description Type of content representation used for the value field.
             * @enum {string}
             */
            representation?: "storage" | "atlas_doc_format" | "raw";
            /** @description Body of the custom content, in the format found in the representation field. */
            value?: string;
        };
        /** @description Body of the custom content. Only one body format should be specified as the property
         *     for this object, e.g. `storage`. */
        CustomContentNestedBodyWrite: {
            storage?: components["schemas"]["CustomContentBodyWrite"];
            atlas_doc_format?: components["schemas"]["CustomContentBodyWrite"];
            raw?: components["schemas"]["CustomContentBodyWrite"];
        };
        ChildPage: {
            /** @description ID of the page. */
            id?: string;
            status?: components["schemas"]["OnlyArchivedAndCurrentContentStatus"];
            /** @description Title of the page. */
            title?: string;
            /** @description ID of the space the page is in. */
            spaceId?: string;
            /**
             * Format: int32
             * @description Position of child page within the given parent page tree.
             */
            childPosition?: number | null;
        };
        ChildCustomContent: {
            /** @description ID of the child custom content. */
            id?: string;
            status?: components["schemas"]["OnlyArchivedAndCurrentContentStatus"];
            /** @description Title of the custom content. */
            title?: string;
            /** @description Custom content type. */
            type?: string;
            /** @description ID of the space the custom content is in. */
            spaceId?: string;
        };
        ChildrenResponse: {
            /** @description ID of the child content. */
            id?: string;
            status?: components["schemas"]["OnlyArchivedAndCurrentContentStatus"];
            /** @description Title of the child content. */
            title?: string;
            /** @description Hierarchical content type (database/embed/folder/page/whiteboard). */
            type?: string;
            /** @description ID of the space the content is in. */
            spaceId?: string;
            /**
             * Format: int32
             * @description Numerical value indicating position of the content relative to its siblings (with the same parentId) within the content tree.
             *     If the content is sorted by childPosition, it will reflect the default content ordering within the content tree.
             */
            childPosition?: number | null;
        };
        DescendantsResponse: {
            /** @description ID of the descendant. */
            id?: string;
            status?: components["schemas"]["OnlyArchivedAndCurrentContentStatus"];
            /** @description Title of the descendant. */
            title?: string;
            /** @description Hierarchical content type (database/embed/folder/page/whiteboard). */
            type?: string;
            /** @description ID of the parent content. */
            parentId?: string;
            /**
             * Format: int32
             * @description Depth of the descendant in the content tree relative to the content specified in the request.
             */
            depth?: number;
            /**
             * Format: int32
             * @description Numerical value indicating position of the content relative to its siblings (with the same parentId) within the content tree.
             *     If the content is sorted by childPosition, it will reflect the default content ordering within the content tree.
             */
            childPosition?: number | null;
        };
        WhiteboardSingle: {
            /** @description ID of the whiteboard. */
            id?: string;
            /** @description The content type of the object. */
            type?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the whiteboard. */
            title?: string;
            /** @description ID of the parent content, or null if there is no parent content. */
            parentId?: string;
            parentType?: components["schemas"]["ParentContentType"];
            /**
             * Format: int32
             * @description Position of the whiteboard within the given parent page tree.
             */
            position?: number | null;
            /** @description The account ID of the user who created this whiteboard originally. */
            authorId?: string;
            /** @description The account ID of the user who owns this whiteboard. */
            ownerId?: string;
            /**
             * Format: date-time
             * @description Date and time when the whiteboard was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            _links?: components["schemas"]["WhiteboardLinks"];
        };
        DatabaseSingle: {
            /** @description ID of the database. */
            id?: string;
            /** @description The content type of the object. */
            type?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the database. */
            title?: string;
            /** @description ID of the parent content, or null if there is no parent content. */
            parentId?: string;
            parentType?: components["schemas"]["ParentContentType"];
            /**
             * Format: int32
             * @description Position of the database within the given parent page tree.
             */
            position?: number | null;
            /** @description The account ID of the user who created this database originally. */
            authorId?: string;
            /** @description The account ID of the user who owns this database. */
            ownerId?: string;
            /**
             * Format: date-time
             * @description Date and time when the database was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            _links?: components["schemas"]["DatabaseLinks"];
        };
        SmartLinkSingle: {
            /** @description ID of the Smart Link in the content tree. */
            id?: string;
            /** @description The content type of the object. */
            type?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the Smart Link in the content tree. */
            title?: string;
            /** @description ID of the parent content, or null if there is no parent content. */
            parentId?: string;
            parentType?: components["schemas"]["ParentContentType"];
            /**
             * Format: int32
             * @description Position of the Smart Link within the given parent page tree.
             */
            position?: number | null;
            /** @description The account ID of the user who created this Smart Link in the content tree originally. */
            authorId?: string;
            /** @description The account ID of the user who owns this Smart Link in the content tree. */
            ownerId?: string;
            /**
             * Format: date-time
             * @description Date and time when the Smart Link in the content tree was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description The embedded URL of the Smart Link. If the Smart Link does not have an embedded URL, this property will not be included in the response. */
            embedUrl?: string;
            version?: components["schemas"]["Version"];
            _links?: components["schemas"]["SmartLinkLinks"];
        };
        FolderSingle: {
            /** @description ID of the folder. */
            id?: string;
            /** @description The content type of the object. */
            type?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the folder. */
            title?: string;
            /** @description ID of the parent content, or null if there is no parent content. */
            parentId?: string;
            parentType?: components["schemas"]["ParentContentType"];
            /**
             * Format: int32
             * @description Position of the folder within the given parent page tree.
             */
            position?: number | null;
            /** @description The account ID of the user who created this folder. */
            authorId?: string;
            /** @description The account ID of the user who owns this folder. */
            ownerId?: string;
            /**
             * Format: date-time
             * @description Date and time when the folder was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            version?: components["schemas"]["Version"];
            _links?: components["schemas"]["FolderLinks"];
        };
        Ancestor: {
            /** @description ID of the ancestor */
            id?: string;
            type?: components["schemas"]["AncestorType"];
        };
        /**
         * @description The type of ancestor.
         * @enum {string}
         */
        AncestorType: "page" | "whiteboard" | "database" | "embed" | "folder";
        Redaction: {
            /** @description List of specific text ranges to redact within this section */
            redactions?: components["schemas"]["RedactionPointer"][];
        };
        RedactionPointer: {
            /** @description JSON pointer indicating the exact location within the content structure
             *     where redaction should be applied. Points to the text node containing the content to redact.
             *      */
            pointer: string;
            /** @description Starting character index (zero-based) within the target text where redaction begins.
             *      */
            from?: number;
            /** @description Ending character index (zero-based) within the target text where redaction ends (exclusive).
             *     Must be greater than or equal to 'from' value.
             *      */
            to?: number;
            /** @description Optional human-readable reason for the redaction. Used for audit trails and compliance documentation.
             *      */
            reason?: string | null;
        };
        /** @description Response containing details of all redactions that were applied to the content.
         *     Each redaction includes a unique ID for restoration, except that code block redactions cannot be restored.
         *      */
        RedactionResponse: {
            body?: components["schemas"]["RedactionSectionResponse"];
            title?: components["schemas"]["RedactionSectionResponse"];
        };
        RedactionSectionResponse: {
            /** @description List of redactions that were applied to this section */
            redactions?: components["schemas"]["RedactionPointerResponse"][];
        };
        RedactionPointerResponse: {
            /** @description JSON pointer indicating where the redaction was applied */
            pointer?: string;
            /** @description Starting character index where redaction was applied */
            from?: number;
            /** @description Ending character index where redaction was applied */
            to?: number;
            /** @description Reason for the redaction */
            reason?: string;
            /**
             * Format: uuid
             * @description Unique identifier for this redaction. Can be used to restore the redacted content later.
             *
             */
            redactionId?: string;
        };
        SpaceSingle: {
            /** @description ID of the space. */
            id?: string;
            /** @description Key of the space. */
            key?: string;
            /** @description Name of the space. */
            name?: string;
            type?: components["schemas"]["SpaceType"];
            status?: components["schemas"]["SpaceStatus"];
            /** @description The account ID of the user who created this space originally. */
            authorId?: string;
            /**
             * Format: date-time
             * @description Date and time when the space was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description ID of the space's homepage. */
            homepageId?: string;
            description?: components["schemas"]["SpaceDescription"];
            icon?: components["schemas"]["SpaceIcon"];
            labels?: {
                results?: components["schemas"]["Label"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            properties?: {
                results?: components["schemas"]["SpaceProperty"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            operations?: {
                results?: components["schemas"]["Operation"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            permissions?: {
                results?: components["schemas"]["SpacePermissionAssignment"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            _links?: components["schemas"]["SpaceLinks"];
        };
        SpaceBulk: {
            /** @description ID of the space. */
            id?: string;
            /** @description Key of the space. */
            key?: string;
            /** @description Name of the space. */
            name?: string;
            type?: components["schemas"]["SpaceType"];
            status?: components["schemas"]["SpaceStatus"];
            /** @description The account ID of the user who created this space originally. */
            authorId?: string;
            /**
             * Format: date-time
             * @description Date and time when the space was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description ID of the space's homepage. */
            homepageId?: string;
            description?: components["schemas"]["SpaceDescription"];
            icon?: components["schemas"]["SpaceIcon"];
            _links?: components["schemas"]["SpaceLinks"];
        };
        /** @description Contains fields for each representation type requested. */
        SpaceDescription: {
            plain?: components["schemas"]["BodyType"];
            view?: components["schemas"]["BodyType"];
        };
        /** @description The icon of the space */
        SpaceIcon: {
            /** @description The path (relative to base URL) at which the space's icon can be retrieved. The format should be like `/wiki/download/...` or `/wiki/aa-avatar/...` */
            path?: string;
            /** @description The path (relative to base URL) that can be used to retrieve a link to download the space icon. 3LO apps should use this link instead of the value provided
             *     in the `path` property to retrieve the icon.
             *
             *     Currently this field is only returned for `global` spaces and not `personal` spaces.
             *      */
            apiDownloadLink?: string;
        };
        SpacePermission: {
            /** @description The identifier for the space permission. */
            id?: string;
            /** @description The display name for the space permission. */
            displayName?: string;
            /** @description Describes the space permission’s usage. */
            description?: string;
            /** @description The permissions required for this permission to be enabled. */
            requiredPermissionIds?: string[];
        };
        SpacePermissionAssignment: {
            /** @description ID of the space permission. */
            id?: string;
            /** @description The entity the space permissions corresponds to. */
            principal?: {
                /** @enum {string} */
                type?: "user" | "group" | "role";
                /** @description ID of the entity. */
                id?: string;
            };
            /** @description The operation the space permission corresponds to. */
            operation?: {
                /**
                 * @description The type of operation.
                 * @enum {string}
                 */
                key?: "use" | "create" | "read" | "update" | "delete" | "copy" | "move" | "export" | "purge" | "purge_version" | "administer" | "restore" | "create_space" | "restrict_content" | "archive";
                /**
                 * @description The type of entity the operation type targets.
                 * @enum {string}
                 */
                targetType?: "page" | "blogpost" | "comment" | "attachment" | "whiteboard" | "database" | "embed" | "folder" | "space" | "application" | "userProfile";
            };
        };
        SpaceRole: {
            /** @description The identifier for the space role. */
            id?: string;
            type?: components["schemas"]["RoleType"];
            /** @description The display name for the space role. */
            displayName?: string;
            /** @description The description for the space role’s usage. */
            description?: string;
            /** @description The space permissions the space role is comprised of. */
            spacePermissions?: string[];
        };
        SpaceRoleAssignment: {
            principal?: components["schemas"]["Principal"];
            /** @description The role to which the principal is assigned. */
            roleId?: string;
        };
        /** @description The principal of the role assignment. */
        Principal: {
            principalType?: components["schemas"]["PrincipalType"];
            /** @description The principal ID. */
            principalId?: string;
        };
        /**
         * @description The principal type.
         * @enum {string}
         */
        PrincipalType: "USER" | "GROUP" | "ACCESS_CLASS";
        /**
         * @description The role type.
         * @enum {string}
         */
        RoleType: "SYSTEM" | "CUSTOM";
        SpaceProperty: {
            /** @description ID of the space property. */
            id?: string;
            /** @description Key of the space property. */
            key?: string;
            /** @description Value of the space property. */
            value?: unknown;
            /**
             * Format: date-time
             * @description RFC3339 compliant date time at which the property was created.
             */
            createdAt?: string;
            /** @description Atlassian account ID of the user that created the space property. */
            createdBy?: string;
            version?: {
                /**
                 * Format: date-time
                 * @description RFC3339 compliant date time at which the property's current version was created.
                 */
                createdAt?: string;
                /** @description Atlassian account ID of the user that created the space property's current version. */
                createdBy?: string;
                /** @description Message associated with the current version. */
                message?: string;
                /**
                 * Format: int32
                 * @description The space property's current version number.
                 */
                number?: number;
            };
        };
        SpacePropertyCreateRequest: {
            /** @description Key of the space property */
            key?: string;
            /** @description Value of the space property. */
            value?: unknown;
        };
        SpacePropertyUpdateRequest: {
            /** @description Key of the space property */
            key?: string;
            /** @description Value of the space property. */
            value?: unknown;
            /** @description New version number and associated message */
            version?: {
                /**
                 * Format: int32
                 * @description Version number of the new version. Should be 1 more than the current version number.
                 */
                number?: number;
                /** @description Message to be associated with the new version. */
                message?: string;
            };
        };
        /**
         * @description The type of space.
         * @enum {string}
         */
        SpaceType: "global" | "collaboration" | "knowledge_base" | "personal";
        /**
         * @description The status of the space.
         * @enum {string}
         */
        SpaceStatus: "current" | "archived";
        Task: {
            /** @description ID of the task. */
            id?: string;
            /** @description Local ID of the task. This ID is local to the corresponding page or blog post. */
            localId?: string;
            /** @description ID of the space the task is in. */
            spaceId?: string;
            /** @description ID of the page the task is in. */
            pageId?: string;
            /** @description ID of the blog post the task is in. */
            blogPostId?: string;
            /**
             * @description Status of the task.
             * @enum {string}
             */
            status?: "complete" | "incomplete";
            body?: components["schemas"]["TaskBodySingle"];
            /** @description Account ID of the user who created this task. */
            createdBy?: string;
            /** @description Account ID of the user to whom this task is assigned. */
            assignedTo?: string;
            /** @description Account ID of the user who completed this task. */
            completedBy?: string;
            /**
             * Format: date-time
             * @description Date and time when the task was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Date and time when the task was updated. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date and time when the task is due. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            dueAt?: string;
            /**
             * Format: date-time
             * @description Date and time when the task was completed. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            completedAt?: string;
        };
        /**
         * @description The account type of the user.
         * @enum {string}
         */
        AccountType: "atlassian" | "app" | "customer" | "unknown";
        /**
         * @description The account status of the user.
         * @enum {string}
         */
        AccountStatus: "active" | "inactive" | "closed" | "unknown";
        /** @description This object represents an icon. If used as a profilePicture, this may be returned as null, depending on the user's privacy setting. */
        Icon: {
            path: string;
            isDefault: boolean;
        } | null;
        User: {
            /** @description Display name of the user. */
            displayName?: string;
            /** @description Time zone of the user. Depending on the user's privacy
             *     setting, this may return null. */
            timeZone?: string;
            /** @description Space ID of the user's personal space. Returns null, if no personal space for the user. */
            personalSpaceId?: string;
            /** @description Whether the user is an external collaborator. */
            isExternalCollaborator?: boolean;
            accountStatus?: components["schemas"]["AccountStatus"];
            /** @description Account ID of the user. */
            accountId?: string;
            /** @description The email address of the user. Depending on the user's privacy setting, this may return an empty string. */
            email?: string;
            accountType?: components["schemas"]["AccountType"];
            /** @description Public name of the user. */
            publicName?: string;
            profilePicture?: components["schemas"]["Icon"];
        };
        Version: {
            /**
             * Format: date-time
             * @description Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description Message associated with the current version. */
            message?: string;
            /**
             * Format: int32
             * @description The version number.
             */
            number?: number;
            /** @description Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions. */
            minorEdit?: boolean;
            /** @description The account ID of the user who created this version. */
            authorId?: string;
        };
        AttachmentVersion: {
            /**
             * Format: date-time
             * @description Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description Message associated with the current version. */
            message?: string;
            /**
             * Format: int32
             * @description The version number.
             */
            number?: number;
            /** @description Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions. */
            minorEdit?: boolean;
            /** @description The account ID of the user who created this version. */
            authorId?: string;
            attachment?: components["schemas"]["VersionedEntity"];
        };
        BlogPostVersion: {
            /**
             * Format: date-time
             * @description Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description Message associated with the current version. */
            message?: string;
            /**
             * Format: int32
             * @description The version number.
             */
            number?: number;
            /** @description Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions. */
            minorEdit?: boolean;
            /** @description The account ID of the user who created this version. */
            authorId?: string;
            blogpost?: components["schemas"]["VersionedEntity"];
        };
        PageVersion: {
            /**
             * Format: date-time
             * @description Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description Message associated with the current version. */
            message?: string;
            /**
             * Format: int32
             * @description The version number.
             */
            number?: number;
            /** @description Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions. */
            minorEdit?: boolean;
            /** @description The account ID of the user who created this version. */
            authorId?: string;
            page?: components["schemas"]["VersionedEntity"];
        };
        CustomContentVersion: {
            /**
             * Format: date-time
             * @description Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description Message associated with the current version. */
            message?: string;
            /**
             * Format: int32
             * @description The version number.
             */
            number?: number;
            /** @description Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions. */
            minorEdit?: boolean;
            /** @description The account ID of the user who created this version. */
            authorId?: string;
            custom?: components["schemas"]["VersionedEntity"];
        };
        CommentVersion: {
            /**
             * Format: date-time
             * @description Date and time when the version was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
             */
            createdAt?: string;
            /** @description Message associated with the current version. */
            message?: string;
            /**
             * Format: int32
             * @description The version number.
             */
            number?: number;
            /** @description Describes if this version is a minor version. Email notifications and activity stream updates are not created for minor versions. */
            minorEdit?: boolean;
            /** @description The account ID of the user who created this version. */
            authorId?: string;
            comment?: components["schemas"]["VersionedEntity"];
        };
        VersionedEntity: {
            /** @description Title of the entity. */
            title?: string;
            /** @description ID of the entity. */
            id?: string;
            body?: components["schemas"]["BodyBulk"];
        };
        /**
         * @description The sort fields for attachments. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        AttachmentSortOrder: "created-date" | "-created-date" | "modified-date" | "-modified-date";
        /**
         * @description The sort fields for blog posts. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        BlogPostSortOrder: "id" | "-id" | "created-date" | "-created-date" | "modified-date" | "-modified-date";
        /**
         * @description The sort fields for comments. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        CommentSortOrder: "created-date" | "-created-date" | "modified-date" | "-modified-date";
        /**
         * @description The sort fields for content properties. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        ContentPropertySortOrder: "key" | "-key";
        /**
         * @description The sort fields for hierarchical content types. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        ContentSortOrder: "created-date" | "-created-date" | "id" | "-id" | "modified-date" | "-modified-date" | "child-position" | "-child-position" | "title" | "-title";
        /**
         * @description The sort fields for labels. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        LabelSortOrder: "created-date" | "-created-date" | "id" | "-id" | "name" | "-name";
        /**
         * @description The sort fields for child pages. The default sort direction is ascending by child-position. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        ChildPageSortOrder: "created-date" | "-created-date" | "id" | "-id" | "child-position" | "-child-position" | "modified-date" | "-modified-date";
        /**
         * @description The sort fields for child custom content. The default sort direction is ascending by id. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        ChildCustomContentSortOrder: "created-date" | "-created-date" | "id" | "-id" | "modified-date" | "-modified-date";
        /**
         * @description The sort fields for custom content. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        CustomContentSortOrder: "id" | "-id" | "created-date" | "-created-date" | "modified-date" | "-modified-date" | "title" | "-title";
        /**
         * @description The sort fields for pages. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        PageSortOrder: "id" | "-id" | "created-date" | "-created-date" | "modified-date" | "-modified-date" | "title" | "-title";
        /**
         * @description The sort fields for spaces. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        SpaceSortOrder: "id" | "-id" | "key" | "-key" | "name" | "-name";
        /**
         * @description The sort fields for versions. The default sort direction is ascending. To sort in descending order, append a `-` character before the sort field. For example, `fieldName` or `-fieldName`.
         * @enum {string}
         */
        VersionSortOrder: "modified-date" | "-modified-date";
        /**
         * @description Inline comment resolution status
         * @enum {string}
         */
        InlineCommentResolutionStatus: "open" | "reopened" | "resolved" | "dangling";
        InlineCommentProperties: {
            /** @description Property value used to reference the highlighted element in DOM. */
            inlineMarkerRef?: string;
            /** @description Text that is highlighted. */
            inlineOriginalSelection?: string;
            /**
             * @deprecated
             * @description Deprecated, use `inlineMarkerRef` instead.
             */
            "inline-marker-ref"?: string;
            /**
             * @deprecated
             * @description Deprecated, use `inlineOriginalSelection` instead.
             */
            "inline-original-selection"?: string;
        };
        PageCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the page the comment is in. */
            pageId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodyBulk"];
            _links?: components["schemas"]["CommentLinks"];
        };
        PageInlineCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the page the comment is in. */
            pageId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodyBulk"];
            resolutionStatus?: components["schemas"]["InlineCommentResolutionStatus"];
            properties?: components["schemas"]["InlineCommentProperties"];
            _links?: components["schemas"]["CommentLinks"];
        };
        BlogPostCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the blog post the comment is in. */
            blogPostId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodyBulk"];
            _links?: components["schemas"]["CommentLinks"];
        };
        BlogPostInlineCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the blog post the comment is in. */
            blogPostId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodyBulk"];
            resolutionStatus?: components["schemas"]["InlineCommentResolutionStatus"];
            properties?: components["schemas"]["InlineCommentProperties"];
            _links?: components["schemas"]["CommentLinks"];
        };
        ChildrenCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the parent comment the child comment is in. */
            parentCommentId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodyBulk"];
            _links?: components["schemas"]["CommentLinks"];
        };
        InlineCommentChildrenModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the parent comment the child comment is in. */
            parentCommentId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodyBulk"];
            resolutionStatus?: components["schemas"]["InlineCommentResolutionStatus"];
            properties?: components["schemas"]["InlineCommentProperties"];
            _links?: components["schemas"]["CommentLinks"];
        };
        AttachmentCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the attachment containing the comment. */
            attachmentId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodySingle"];
            _links?: components["schemas"]["CommentLinks"];
        };
        CustomContentCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the custom content containing the comment. */
            customContentId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodySingle"];
            _links?: components["schemas"]["CommentLinks"];
        };
        FooterCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the blog post containing the comment if the comment is on a blog post. */
            blogPostId?: string;
            /** @description ID of the page containing the comment if the comment is on a page. */
            pageId?: string;
            /** @description ID of the attachment containing the comment if the comment is on an attachment. */
            attachmentId?: string;
            /** @description ID of the custom content containing the comment if the comment is on a custom content. */
            customContentId?: string;
            /** @description ID of the parent comment if the comment is a reply. */
            parentCommentId?: string;
            version?: components["schemas"]["Version"];
            properties?: {
                results?: components["schemas"]["ContentProperty"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            operations?: {
                results?: components["schemas"]["Operation"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            likes?: {
                results?: components["schemas"]["Like"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            versions?: {
                results?: components["schemas"]["Version"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            body?: components["schemas"]["BodySingle"];
            _links?: components["schemas"]["CommentLinks"];
        };
        InlineCommentModel: {
            /** @description ID of the comment. */
            id?: string;
            status?: components["schemas"]["ContentStatus"];
            /** @description Title of the comment. */
            title?: string;
            /** @description ID of the blog post containing the comment if the comment is on a blog post. */
            blogPostId?: string;
            /** @description ID of the page containing the comment if the comment is on a page. */
            pageId?: string;
            /** @description ID of the parent comment if the comment is a reply. */
            parentCommentId?: string;
            version?: components["schemas"]["Version"];
            body?: components["schemas"]["BodySingle"];
            /** @description Atlassian Account ID of last person who modified the resolve state of the comment. Null until comment is resolved or reopened. */
            resolutionLastModifierId?: string;
            /**
             * Format: date-time
             * @description Timestamp of the last modification to the comment's resolution status. Null until comment is resolved or reopened.
             */
            resolutionLastModifiedAt?: string;
            resolutionStatus?: components["schemas"]["InlineCommentResolutionStatus"];
            properties?: {
                results?: components["schemas"]["ContentProperty"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
                /** @description Property value used to reference the highlighted element in DOM. */
                inlineMarkerRef?: string;
                /** @description Text that is highlighted. */
                inlineOriginalSelection?: string;
                /**
                 * @deprecated
                 * @description Deprecated, use `inlineMarkerRef` instead.
                 */
                "inline-marker-ref"?: string;
                /**
                 * @deprecated
                 * @description Deprecated, use `inlineOriginalSelection` instead.
                 */
                "inline-original-selection"?: string;
            };
            operations?: {
                results?: components["schemas"]["Operation"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            likes?: {
                results?: components["schemas"]["Like"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            versions?: {
                results?: components["schemas"]["Version"][];
                meta?: components["schemas"]["OptionalFieldMeta"];
                _links?: components["schemas"]["OptionalFieldLinks"];
            };
            _links?: components["schemas"]["CommentLinks"];
        };
        CreateFooterCommentModel: {
            /** @description ID of the containing blog post, if intending to create a top level footer comment. Do not provide if creating a reply. */
            blogPostId?: string;
            /** @description ID of the containing page, if intending to create a top level footer comment. Do not provide if creating a reply. */
            pageId?: string;
            /** @description ID of the parent comment, if intending to create a reply. Do not provide if creating a top level comment. */
            parentCommentId?: string;
            /** @description ID of the attachment, if intending to create a comment against an attachment. */
            attachmentId?: string;
            /** @description ID of the custom content, if intending to create a comment against a custom content. */
            customContentId?: string;
            body?: components["schemas"]["CommentBodyWrite"] | components["schemas"]["CommentNestedBodyWrite"];
        };
        CreateInlineCommentModel: {
            /** @description ID of the containing blog post, if intending to create a top level footer comment. Do not provide if creating a reply. */
            blogPostId?: string;
            /** @description ID of the containing page, if intending to create a top level footer comment. Do not provide if creating a reply. */
            pageId?: string;
            /** @description ID of the parent comment, if intending to create a reply. Do not provide if creating a top level comment. */
            parentCommentId?: string;
            body?: components["schemas"]["CommentBodyWrite"] | components["schemas"]["CommentNestedBodyWrite"];
            /** @description Object describing the text to highlight on the page/blog post. Only applicable for top level inline comments (not replies) and required in that case. */
            inlineCommentProperties?: {
                /** @description The text to highlight */
                textSelection?: string;
                /** @description The number of matches for the selected text on the page (should be strictly greater than textSelectionMatchIndex) */
                textSelectionMatchCount?: number;
                /** @description The match index to highlight. This is zero-based. E.g. if you have 3 occurrences of "hello world" on a page
                 *     and you want to highlight the second occurrence, you should pass 1 for textSelectionMatchIndex and 3 for textSelectionMatchCount. */
                textSelectionMatchIndex?: number;
            };
        };
        UpdateFooterCommentModel: {
            version?: {
                /** @description Number of new version. Should be 1 higher than current version of the comment. */
                number?: number;
                /** @description Optional message store for the new version. */
                message?: string;
            };
            body?: components["schemas"]["CommentBodyWrite"] | components["schemas"]["CommentNestedBodyWrite"];
        };
        UpdateInlineCommentModel: {
            version?: {
                /** @description Number of new version. Should be 1 higher than current version of the comment. */
                number?: number;
                /** @description Optional message store for the new version. */
                message?: string;
            };
            body?: components["schemas"]["CommentBodyWrite"] | components["schemas"]["CommentNestedBodyWrite"];
            /** @description Resolved state of the comment. Set to true to resolve the comment, set to false to reopen it. If
             *     matching the existing state (i.e. true -> resolved or false -> open/reopened) , no change will occur. A dangling
             *     comment cannot be updated. */
            resolved?: boolean;
        };
        AbstractPageLinks: {
            /** @description Web UI link of the content. */
            webui?: string;
            /** @description Edit UI link of the content. */
            editui?: string;
            /** @description Web UI link of the content. */
            tinyui?: string;
        };
        AttachmentLinks: {
            /** @description Web UI link of the content. */
            webui?: string;
            /** @description Download link of the content. */
            download?: string;
        };
        CustomContentLinks: {
            /** @description Web UI link of the content. */
            webui?: string;
        };
        CommentLinks: {
            /** @description Web UI link of the content. */
            webui?: string;
        };
        DatabaseLinks: {
            /** @description Web UI link of the content. */
            webui?: string;
        };
        FolderLinks: {
            /** @description Web UI link of the content. */
            webui?: string;
        };
        SmartLinkLinks: {
            /** @description Web UI link of the content. */
            webui?: string;
        };
        SpaceLinks: {
            /** @description Web UI link of the space. */
            webui?: string;
        };
        WhiteboardLinks: {
            /** @description Web UI link of the content. */
            webui?: string;
            /** @description Edit UI link of the content. */
            editui?: string;
        };
        /** @description Details about data policies. */
        DataPolicyMetadata: {
            /** @description Whether the workspace contains any content blocked for (inaccessible to) the requesting client application. */
            readonly anyContentBlocked?: boolean;
        };
        DataPolicySpace: {
            /** @description ID of the space. */
            id?: string;
            /** @description Key of the space. */
            key?: string;
            /** @description Name of the space. */
            name?: string;
            description?: components["schemas"]["SpaceDescription"];
            dataPolicy?: {
                /** @description Whether the space contains any content blocked for (inaccessible to) the requesting client application. */
                readonly anyContentBlocked?: boolean;
            };
            icon?: components["schemas"]["SpaceIcon"];
            _links?: components["schemas"]["SpaceLinks"];
        };
        OptionalFieldMeta: {
            /** @description Indicates if there are more available results that can be fetched. */
            hasMore?: boolean;
            /** @description A token that can be used in the query parameter of the endpoint returned in the `_links` property to retrieve the next set of results. */
            cursor?: string;
        };
        OptionalFieldLinks: {
            /** @description A relative URL that can be used to fetch results beyond what this include parameter retrieves. */
            self?: string;
        };
        MultiEntityLinks: {
            /** @description Used for pagination. Contains the relative URL for the next set of results, using a cursor query parameter.
             *     This property will not be present if there is no additional data available. */
            next?: string;
            /** @description Base url of the Confluence site. */
            base?: string;
        };
        /**
         * ClassificationLevel
         * @description A unit of [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/) defined by an organiation.
         *     A classification level may be associated with specific storage and handling requirements or expectations.
         */
        ClassificationLevel: {
            /** @description The ID of the classification level. */
            id?: string;
            /** @description The status of the classification level. */
            status?: components["schemas"]["ClassificationLevelStatus"];
            /** @description The order of the classification level object. */
            order?: number;
            /** @description The name of the classification level object. */
            name?: string;
            /** @description The description of the classification level object. */
            description?: string;
            /** @description The guideline of the classification level object. */
            guideline?: string;
            /** @description The color of the classification level object. */
            color?: components["schemas"]["ClassificationLevelColor"];
        };
        /** @enum {string} */
        ClassificationLevelColor: "RED" | "RED_BOLD" | "ORANGE" | "YELLOW" | "GREEN" | "BLUE" | "NAVY" | "TEAL" | "PURPLE" | "GREY" | "LIME";
        /** @enum {string} */
        ClassificationLevelStatus: "DRAFT" | "PUBLISHED" | "ARCHIVED";
    };
    responses: never;
    parameters: never;
    requestBodies: {
        AdminKeyRequest: {
            content: {
                "application/json": {
                    /**
                     * Format: int32
                     * @description The requested duration of admin key access in minutes, up to a maximum of 60 minutes, after which the issued admin key will automatically expire.
                     * @example 60
                     */
                    durationInMinutes?: number;
                };
            };
        };
        BlogPostCreateRequest: {
            content: {
                "application/json": {
                    /** @description ID of the space */
                    spaceId: string;
                    /**
                     * @description The status of the blog post, specifies if the blog post will be created as a new blog post or a draft
                     * @enum {string}
                     */
                    status?: "current" | "draft";
                    /** @description Title of the blog post, required if creating non-draft. */
                    title?: string;
                    body?: components["schemas"]["BlogPostBodyWrite"] | components["schemas"]["BlogPostNestedBodyWrite"];
                    /** @description Created date of the blog post in the format of "yyyy-MM-ddTHH:mm:ss.SSSZ". */
                    createdAt?: string;
                };
            };
        };
        BlogPostUpdateRequest: {
            content: {
                "application/json": {
                    /** @description Id of the blog post. */
                    id: string;
                    /**
                     * @description The updated status of the blog post.
                     *
                     *     Note, if you change the status of a blog post from 'current' to 'draft' and it has an existing draft, the existing draft will be deleted in favor of the updated draft.
                     *     Additionally, this endpoint can be used to restore a 'trashed' or 'deleted' blog post to 'current' status. For restoration, blog post contents will not be updated and only the blog post status will be changed.
                     * @enum {string}
                     */
                    status: "current" | "draft";
                    /** @description Title of the blog post. */
                    title: string;
                    /** @description ID of the containing space.
                     *
                     *     This currently **does not support moving the blog post to a different space**. */
                    spaceId?: string;
                    body: components["schemas"]["BlogPostBodyWrite"] | components["schemas"]["BlogPostNestedBodyWrite"];
                    version: {
                        /**
                         * Format: int32
                         * @description The new version number of the updated blog post.
                         *     Set this to the current version number plus one, unless you are updating the status to 'draft' which requires a version number of 1.
                         *
                         *     If you don't know the current version number, use Get blog post by id.
                         */
                        number?: number;
                        /** @description An optional message to be stored with the version. */
                        message?: string;
                    };
                    /** @description Created date of the blog post in the format of "yyyy-MM-ddTHH:mm:ss.SSSZ". */
                    createdAt?: string;
                };
            };
        };
        ContentIdToContentTypeRequest: {
            content: {
                "application/json": {
                    /** @description The content ids to convert. They may be provided as strings or numbers. */
                    contentIds: (string | number)[];
                };
            };
        };
        CustomContentCreateRequest: {
            content: {
                "application/json": {
                    /** @description Type of custom content. */
                    type: string;
                    /**
                     * @description The status of the custom content. Defaults to `current` when status not provided.
                     * @enum {string}
                     */
                    status?: "current" | "draft";
                    /** @description ID of the containing space. */
                    spaceId?: string;
                    /** @description ID of the containing page. */
                    pageId?: string;
                    /** @description ID of the containing Blog Post. */
                    blogPostId?: string;
                    /** @description ID of the containing custom content. */
                    customContentId?: string;
                    /** @description Title of the custom content. */
                    title: string;
                    body: components["schemas"]["CustomContentBodyWrite"] | components["schemas"]["CustomContentNestedBodyWrite"];
                };
            };
        };
        CustomContentUpdateRequest: {
            content: {
                "application/json": {
                    /** @description Id of custom content. */
                    id: string;
                    /** @description Type of custom content. */
                    type: string;
                    /**
                     * @description The status of the custom content.
                     * @enum {string}
                     */
                    status: "current";
                    /** @description ID of the containing space (must be the same as the spaceId of the space the custom content was created in). */
                    spaceId?: string;
                    /** @description ID of the containing page. */
                    pageId?: string;
                    /** @description ID of the containing Blog Post. */
                    blogPostId?: string;
                    /** @description ID of the containing custom content. */
                    customContentId?: string;
                    /** @description Title of the custom content. */
                    title: string;
                    body: components["schemas"]["CustomContentBodyWrite"] | components["schemas"]["CustomContentNestedBodyWrite"];
                    version: {
                        /**
                         * Format: int32
                         * @description The version number, must be incremented by one.
                         */
                        number?: number;
                        /** @description An optional message to be stored with the version. */
                        message?: string;
                    };
                };
            };
        };
        PageCreateRequest: {
            content: {
                "application/json": {
                    /** @description ID of the space. */
                    spaceId: string;
                    /**
                     * @description The status of the page, published or draft.
                     * @enum {string}
                     */
                    status?: "current" | "draft";
                    /** @description Title of the page, required if page status is not draft. */
                    title?: string;
                    /** @description The parent content ID of the page. If the `root-level` query parameter is set to false and a value is
                     *     not supplied for this parameter, then the space homepage's ID will be used. If the `root-level` query
                     *     parameter is set to true, then a value may not be supplied for this parameter. */
                    parentId?: string;
                    body?: components["schemas"]["PageBodyWrite"] | components["schemas"]["PageNestedBodyWrite"];
                    /**
                     * @description The subtype of the page. Provide the subtype live to create a live doc or no subtype to create a page.
                     * @enum {string}
                     */
                    subtype?: "live";
                };
            };
        };
        PageUpdateRequest: {
            content: {
                "application/json": {
                    /** @description Id of the page. */
                    id: string;
                    /**
                     * @description The updated status of the page.
                     *
                     *     Note, if you change the status of a page from 'current' to 'draft' and it has an existing draft, the existing draft will be deleted in favor of the updated draft.
                     *     Additionally, this endpoint can be used to restore a 'trashed' or 'deleted' page to 'current' status. For restoration, page contents will not be updated and only the page status will be changed.
                     * @enum {string}
                     */
                    status: "current" | "draft";
                    /** @description Title of the page. */
                    title: string;
                    /**
                     * Format: string
                     * @description ID of the containing space.
                     *
                     *     This currently **does not support moving the page to a different space**.
                     */
                    spaceId?: unknown;
                    /**
                     * Format: string
                     * @description ID of the parent content.
                     *
                     *     This allows the page to be moved under a different parent within the same space.
                     */
                    parentId?: unknown;
                    /**
                     * Format: string
                     * @description Account ID of the page owner.
                     *
                     *     This allows page ownership to be transferred to another user.
                     */
                    ownerId?: unknown;
                    body: components["schemas"]["PageBodyWrite"] | components["schemas"]["PageNestedBodyWrite"];
                    version: {
                        /**
                         * Format: int32
                         * @description The new version of the updated page.
                         *     Set this to the current version number plus one, unless you are updating the status to 'draft' which requires a version number of 1.
                         *
                         *     If you don't know the current version number, use Get page by id.
                         */
                        number?: number;
                        /** @description An optional message to be stored with the version. */
                        message?: string;
                    };
                };
            };
        };
        PageTitleUpdateRequest: {
            content: {
                "application/json": {
                    /**
                     * @description The status of the page, current or draft.
                     * @enum {string}
                     */
                    status: "current" | "draft";
                    /** @description The updated title for the page */
                    title: string;
                };
            };
        };
        WhiteboardCreateRequest: {
            content: {
                "application/json": {
                    /** @description ID of the space. */
                    spaceId: string;
                    /** @description Title of the whiteboard. */
                    title?: string;
                    /** @description The parent content ID of the whiteboard. */
                    parentId?: string;
                    /**
                     * @description Providing a template key will add that template to the new whiteboard.
                     * @enum {string}
                     */
                    templateKey?: "2x2-prioritization" | "4ls-retro" | "annual-calendar" | "brainwriting" | "concept-map" | "crazy-8s" | "daily-sync" | "disruptive-brainstorm" | "dot-voting" | "elevator-pitch" | "flow-chart" | "gap-analysis" | "ice-breakers" | "incident-postmortem" | "journey-mapping-kit" | "kanban-board" | "lean-coffee" | "network-of-teams" | "org-chart" | "pi-planning" | "prioritization" | "prioritization-experiment" | "product-roadmap" | "product-vision-board" | "rice" | "sailboat-retro" | "service-blueprint" | "simple-retrospective" | "sprint-planning" | "sticky-note-pack" | "swimlanes" | "team-formation-guide" | "timeline" | "timeline-workflow" | "user-story-map" | "workflow" | "vision-board" | "venn-diagram" | "storyboard" | "action-plan" | "root-cause-analysis" | "executive-summary" | "stakeholder-mapping" | "annual-calendar-2025-2026" | "health-monitor" | "okr-planning" | "swot-analysis" | "poker-planning" | "fishbone-diagram" | "risk-assessment" | "bounded-context" | "hopes-and-fears" | "swimlane-vertical";
                    /**
                     * @description If templateKey is provided, locale will decide which language the template will be created with. If locale is omitted, the user's locale will be used.
                     * @enum {string}
                     */
                    locale?: "de-DE" | "cs-CZ" | "ko-KR" | "fr-FR" | "it-IT" | "ja-JP" | "nl-NL" | "nb-NO" | "da-DK" | "sv-SE" | "fi-FI" | "ru-RU" | "pl-PL" | "tr-TR" | "hu-HU" | "en-GB" | "en-US" | "pt-BR" | "zh-CN" | "zh-TW" | "es-ES";
                };
            };
        };
        DatabaseCreateRequest: {
            content: {
                "application/json": {
                    /** @description ID of the space. */
                    spaceId: string;
                    /** @description Title of the database. */
                    title?: string;
                    /** @description The parent content ID of the database. */
                    parentId?: string;
                };
            };
        };
        RedactionRequest: {
            content: {
                "application/json": {
                    /**
                     * Format: date-time
                     * @description Timestamp when the content was last updated.
                     */
                    createdAt: string;
                    /** @description Whether to clean up previous versions containing the redaction. When true, historical versions of the content that contain the redacted text will be squashed. */
                    cleanHistory: boolean;
                    body?: {
                        redactions?: components["schemas"]["Redaction"][];
                    };
                    title?: {
                        redactions?: components["schemas"]["Redaction"][];
                    };
                };
            };
        };
        SmartLinkCreateRequest: {
            content: {
                "application/json": {
                    /** @description ID of the space. */
                    spaceId: string;
                    /** @description Title of the Smart Link in the content tree. */
                    title?: string;
                    /** @description The parent content ID of the Smart Link in the content tree. */
                    parentId?: string;
                    /** @description The URL that the Smart Link in the content tree should be populated with. */
                    embedUrl?: string;
                };
            };
        };
        FolderCreateRequest: {
            content: {
                "application/json": {
                    /** @description ID of the space. */
                    spaceId: string;
                    /** @description Title of the folder. */
                    title?: string;
                    /** @description The parent content ID of the folder. */
                    parentId?: string;
                };
            };
        };
        TaskUpdateRequest: {
            content: {
                "application/json": {
                    /** @description ID of the task. */
                    id?: string;
                    /** @description Local ID of the task. This ID is local to the corresponding page or blog post. */
                    localId?: string;
                    /** @description ID of the space the task is in. */
                    spaceId?: string;
                    /** @description ID of the page the task is in. */
                    pageId?: string;
                    /** @description ID of the blog post the task is in. */
                    blogPostId?: string;
                    /**
                     * @description Status of the task.
                     * @enum {string}
                     */
                    status: "complete" | "incomplete";
                    /** @description Account ID of the user who created this task. */
                    createdBy?: string;
                    /** @description Account ID of the user to whom this task is assigned. */
                    assignedTo?: string;
                    /** @description Account ID of the user who completed this task. */
                    completedBy?: string;
                    /**
                     * Format: date-time
                     * @description Date and time when the task was created. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
                     */
                    createdAt?: string;
                    /**
                     * Format: date-time
                     * @description Date and time when the task was updated. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
                     */
                    updatedAt?: string;
                    /**
                     * Format: date-time
                     * @description Date and time when the task is due. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
                     */
                    dueAt?: string;
                    /**
                     * Format: date-time
                     * @description Date and time when the task was completed. In format "YYYY-MM-DDTHH:mm:ss.sssZ".
                     */
                    completedAt?: string;
                };
            };
        };
        CheckAccessOrInviteByEmailRequest: {
            content: {
                "application/json": {
                    /** @description List of emails to check access to site. */
                    emails: string[];
                };
            };
        };
        BulkUsersRequest: {
            content: {
                "application/json": {
                    /** @description List of accountIds to retrieve user info for. */
                    accountIds: string[];
                };
            };
        };
        SetSpaceRoleAssignmentRequest: {
            content: {
                "application/json": {
                    principal: components["schemas"]["Principal"];
                    /** @description The role to which the principal is assigned. */
                    roleId?: string;
                }[];
            };
        };
        SpaceCreateRequest: {
            content: {
                "application/json": {
                    /** @description The name of the space to be created. */
                    name: string;
                    /** @description The key for the new space. See [Space Keys](https://support.atlassian.com/confluence-cloud/docs/create-a-space/). If the key property is not provided, the alias property is required to be used instead. */
                    key?: string;
                    /** @description This field will be used as the new identifier for the space in confluence page URLs. If the alias property is not provided, the key property is required to be used instead. Maximum 255 alphanumeric characters in length. */
                    alias?: string;
                    /** @description The description of the new/updated space. Note, only the 'plain' representation is currently supported. */
                    description?: {
                        /** @description The space description. */
                        value?: string;
                        /** @description The format of the description. */
                        representation?: string;
                    };
                    roleAssignments?: {
                        principal?: components["schemas"]["Principal"];
                        /** @description The role to which the principal is assigned. */
                        roleId?: string;
                    }[];
                };
            };
        };
        SpaceDefaultClassificationLevelUpdateRequest: {
            content: {
                "application/json": {
                    /** @description The ID of the classification level. */
                    id: string;
                };
            };
        };
        ContentClassificationLevelUpdateRequest: {
            content: {
                "application/json": {
                    /** @description The ID of the classification level. */
                    id: string;
                    /**
                     * @description Status of the content.
                     * @enum {string}
                     */
                    status: "current" | "draft";
                };
            };
        };
        ContentClassificationLevelDeleteRequest: {
            content: {
                "application/json": {
                    /**
                     * @description Status of the content.
                     * @enum {string}
                     */
                    status: "current" | "draft";
                };
            };
        };
        LiveEditContentClassificationLevelUpdateRequest: {
            content: {
                "application/json": {
                    /** @description The ID of the classification level. */
                    id: string;
                    /**
                     * @description Status of the content.
                     * @enum {string}
                     */
                    status: "current";
                };
            };
        };
        LiveEditContentClassificationLevelResetRequest: {
            content: {
                "application/json": {
                    /**
                     * @description Status of the content.
                     * @enum {string}
                     */
                    status: "current";
                };
            };
        };
    };
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getAdminKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if an admin key is currently enabled for the calling user. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AdminKeyResponse"];
                };
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not currently have an admin key, if the calling user does not have permission to use admin keys, or if the site is not a Confluence Cloud Premium or Enterprise instance. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    enableAdminKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["AdminKeyRequest"];
        responses: {
            /** @description Returned if a new admin key is successfully issued for the calling user. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AdminKeyResponse"];
                };
            };
            /** @description Returned if the request body contains an invalid `durationInMinutes`. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to use admin keys or if the site is not a Confluence Cloud Premium or Enterprise instance. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    disableAdminKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if admin key access was successfully disabled for the calling user or if the user did not have an admin key in the first place. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to use admin keys or if the site is not a Confluence Cloud Premium or Enterprise instance. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachments: {
        parameters: {
            query?: {
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["AttachmentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Filter the results to attachments based on their status. By default, `current` and `archived` are used. */
                status?: ("current" | "archived" | "trashed")[];
                /** @description Filters on the mediaType of attachments. Only one may be specified. */
                mediaType?: string;
                /** @description Filters on the file-name of attachments. Only one may be specified. */
                filename?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested attachments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information.  Example response header format: `Link: </wiki/api/v2/attachments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["AttachmentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachmentById: {
        parameters: {
            query?: {
                /** @description Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details. */
                version?: number;
                /** @description Includes labels associated with this attachment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-labels"?: boolean;
                /** @description Includes content properties associated with this attachment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
                /** @description Includes operations associated with this attachment in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes versions associated with this attachment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-versions"?: boolean;
                /** @description Includes the current version associated with this attachment in the response.
                 *     By default this is included and can be omitted by setting the value to `false`. */
                "include-version"?: boolean;
                /** @description Includes collaborators on the attachment. */
                "include-collaborators"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the attachment to be returned. If you don't know the attachment's ID, use Get attachments for page/blogpost/custom content. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested attachment is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AttachmentSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested attachment or the attachment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteAttachment: {
        parameters: {
            query?: {
                /** @description If attempting to purge the attachment. */
                purge?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the attachment to be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the attachment was successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided attachment does not exist
             *     - The user does not have permissions to view the container of the attachment
             *     - The user does not have the needed permissions to delete an attachment in the space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachmentLabels: {
        parameters: {
            query?: {
                /** @description Filter the results to labels based on their prefix. */
                prefix?: "my" | "team" | "global" | "system";
                /** @description Used to sort the result by a particular field. */
                sort?: string;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the attachment for which labels should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested labels are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/attachments/<id>/labels?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Label"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent content of the requested attachment or the attachment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachmentOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the attachment for which operations should be returned. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent content of the requested attachment or the attachment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachmentContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the attachment for which content properties should be returned. */
                "attachment-id": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/attachments/<attachment-id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified attachment or the attachment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createAttachmentProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the attachment to create a property for. */
                "attachment-id": string;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified attachment or the attachment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachmentContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the attachment for which content properties should be returned. */
                "attachment-id": string;
                /** @description The ID of the content property to be returned */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified attachment,the attachment was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateAttachmentPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the attachment the property belongs to. */
                "attachment-id": string;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified attachment or the attachment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteAttachmentPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the attachment the property belongs to. */
                "attachment-id": string;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified attachment or the attachment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachmentVersions: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["VersionSortOrder"];
            };
            header?: never;
            path: {
                /** @description The ID of the attachment to be queried for its versions. If you don't know the attachment ID, use Get attachments and filter the results. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested attachment versions are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/attachments/<id>/versions?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["AttachmentVersion"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachmentVersionDetails: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the attachment for which version details should be returned. */
                "attachment-id": string;
                /** @description The version number of the attachment to be returned. */
                "version-number": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested version details are successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetailedVersion"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified attachment, the attachment was not found, or the version number does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAttachmentComments: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Version number of the attachment to retrieve comments for. If no version provided, retrieves comments for the latest version. */
                version?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the attachment for which comments should be returned. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the attachment comments were successfully retrieved */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/attachments/<id>/comments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["AttachmentCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     attachment or associated containers. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPosts: {
        parameters: {
            query?: {
                /** @description Filter the results based on blog post ids. Multiple blog post ids can be specified as a comma-separated list. */
                id?: number[];
                /** @description Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list. */
                "space-id"?: number[];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["BlogPostSortOrder"];
                /** @description Filter the results to blog posts based on their status. By default, `current` is used. */
                status?: ("current" | "deleted" | "trashed")[];
                /** @description Filter the results to blog posts based on their title. */
                title?: string;
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of blog posts per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested blog posts are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["BlogPostBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createBlogPost: {
        parameters: {
            query?: {
                /** @description The blog post will be private. Only the user who creates this blog post will have permission to view and edit one. */
                private?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["BlogPostCreateRequest"];
        responses: {
            /** @description Returned if the blog post was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BlogPostSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if invalid values were passed in for any of the enums, a REQUIRED parameter was missing, or if the given title is a duplicate in the space */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided space does not exist
             *     - The user does not have permissions to view the space
             *     - The user does not have the needed permissions to create a blog post in the provided space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the request is too large in size (over 5 MB) */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostById: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentationSingle"];
                /** @description Retrieve the draft version of this blog post. */
                "get-draft"?: boolean;
                /** @description Filter the blog post being retrieved by its status. */
                status?: ("current" | "trashed" | "deleted" | "historical" | "draft")[];
                /** @description Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details. */
                version?: number;
                /** @description Includes labels associated with this blog post in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-labels"?: boolean;
                /** @description Includes content properties associated with this blog post in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
                /** @description Includes operations associated with this blog post in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes likes associated with this blog post in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-likes"?: boolean;
                /** @description Includes versions associated with this blog post in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-versions"?: boolean;
                /** @description Includes the current version associated with this blog post in the response.
                 *     By default this is included and can be omitted by setting the value to `false`. */
                "include-version"?: boolean;
                /** @description Includes whether this blog post has been favorited by the current user. */
                "include-favorited-by-current-user-status"?: boolean;
                /** @description Includes web resources that can be used to render blog post content on a client. */
                "include-webresources"?: boolean;
                /** @description Includes collaborators on the blog post. */
                "include-collaborators"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the blog post to be returned. If you don't know the blog post ID, use Get blog posts and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested blog post is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BlogPostSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateBlogPost: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post to be updated. If you don't know the blog post ID, use Get Blog Posts and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["BlogPostUpdateRequest"];
        responses: {
            /** @description Returned if the requested blog post is successfully updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BlogPostSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided blog post does not exist
             *     - The user does not have permissions to view the blog post
             *     - The user does not have the needed permissions to update a blog post in the space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteBlogPost: {
        parameters: {
            query?: {
                /** @description If attempting to purge the blog post. */
                purge?: boolean;
                /** @description If attempting to delete a blog post that is a draft. */
                draft?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the blog post to be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the blog post was successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided blog post does not exist
             *     - The user does not have permissions to view the blog post
             *     - The user does not have the needed permissions to delete a blog post in the space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogpostAttachments: {
        parameters: {
            query?: {
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["AttachmentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Filter the results to attachments based on their status. By default, `current` and `archived` are used. */
                status?: ("current" | "archived" | "trashed")[];
                /** @description Filters on the mediaType of attachments. Only one may be specified. */
                mediaType?: string;
                /** @description Filters on the file-name of attachments. Only one may be specified. */
                filename?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the blog post for which attachments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested attachments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/<id>/attachments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["AttachmentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentByTypeInBlogPost: {
        parameters: {
            query: {
                /** @description The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content. */
                type: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CustomContentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
                 *
                 *     Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned. */
                "body-format"?: components["schemas"]["CustomContentBodyRepresentation"];
            };
            header?: never;
            path: {
                /** @description The ID of the blog post for which custom content should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested custom content is returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/{id}/custom-content?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CustomContentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the given blog post is not found. Returned if the type of custom content is not found. Note, this is distinct from the type being present, but no instances of the type, which would be a 200 with empty results. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostLabels: {
        parameters: {
            query?: {
                /** @description Filter the results to labels based on their prefix. */
                prefix?: "my" | "team" | "global" | "system";
                /** @description Used to sort the result by a particular field. */
                sort?: string;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the blog post for which labels should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested labels are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/<id>/labels?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Label"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostLikeCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post for which like count should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested count is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: int64
                         * @description The count number
                         */
                        count?: number;
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostLikeUsers: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the blog post for which account IDs should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested account IDs are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/<id>/likes/users?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Like"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogpostContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the blog post for which content properties should be returned. */
                "blogpost-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/<blogpost-id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createBlogpostProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post to create a property for. */
                "blogpost-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogpostContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post for which content properties should be returned. */
                "blogpost-id": number;
                /** @description The ID of the property being requested */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/<blogpost-id>/properties/<property-id>?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified blog post,the blog post was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateBlogpostPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post the property belongs to. */
                "blogpost-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteBlogpostPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post the property belongs to. */
                "blogpost-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent content of the requested blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostVersions: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["VersionSortOrder"];
            };
            header?: never;
            path: {
                /** @description The ID of the blog post to be queried for its versions. If you don't know the blog post ID, use Get blog posts and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested blog post versions are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/<id>/versions?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["BlogPostVersion"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostVersionDetails: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post for which version details should be returned. */
                "blogpost-id": number;
                /** @description The version number of the blog post to be returned. */
                "version-number": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested version details are successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetailedVersion"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified blog post, the blog post was not found, or the version number does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    convertContentIdsToContentTypes: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["ContentIdToContentTypeRequest"];
        responses: {
            /** @description Returned if the requested content ids are successfully converted to their content types */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentIdToContentTypeResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentByType: {
        parameters: {
            query: {
                /** @description The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content. */
                type: string;
                /** @description Filter the results based on custom content ids. Multiple custom content ids can be specified as a comma-separated list. */
                id?: number[];
                /** @description Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list. */
                "space-id"?: number[];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CustomContentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
                 *
                 *     Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned. */
                "body-format"?: components["schemas"]["CustomContentBodyRepresentation"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested custom content is returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/custom-content?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CustomContentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the type of custom content is not found. Note, this is distinct from the type being present, but no instances of the type, which would be a 200 with empty results. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createCustomContent: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CustomContentCreateRequest"];
        responses: {
            /** @description Returned if the requested custom content is created successfully. */
            201: {
                headers: {
                    /** @description Relative link to created custom content Example response header format: `location: </wiki/api/v2/custom-content/<id>>`
                     *      */
                    location?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomContentSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the type of custom content is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentById: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
                 *
                 *     Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned. */
                "body-format"?: components["schemas"]["CustomContentBodyRepresentationSingle"];
                /** @description Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details. */
                version?: number;
                /** @description Includes labels associated with this custom content in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-labels"?: boolean;
                /** @description Includes content properties associated with this custom content in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
                /** @description Includes operations associated with this custom content in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes versions associated with this custom content in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-versions"?: boolean;
                /** @description Includes the current version associated with this custom content in the response.
                 *     By default this is included and can be omitted by setting the value to `false`. */
                "include-version"?: boolean;
                /** @description Includes collaborators on the custom content. */
                "include-collaborators"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the custom content to be returned. If you don't know the custom content ID, use Get Custom Content by Type and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested custom content is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomContentSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested custom content or the custom content was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateCustomContent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom content to be updated. If you don't know the custom content ID, use Get Custom Content by Type and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CustomContentUpdateRequest"];
        responses: {
            /** @description Returned if the requested custom content is updated successfully. */
            200: {
                headers: {
                    /** @description Relative link to updated custom content Example response header format: `location: </wiki/api/v2/custom-content/<id>>`
                     *      */
                    location?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomContentSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the type of custom content is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteCustomContent: {
        parameters: {
            query?: {
                /** @description If attempting to purge the custom content. */
                purge?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the custom content to be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the custom content was deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the custom content is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentAttachments: {
        parameters: {
            query?: {
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["AttachmentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Filter the results to attachments based on their status. By default, `current` and `archived` are used. */
                status?: ("current" | "archived" | "trashed")[];
                /** @description Filters on the mediaType of attachments. Only one may be specified. */
                mediaType?: string;
                /** @description Filters on the file-name of attachments. Only one may be specified. */
                filename?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the custom content for which attachments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested attachments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/custom-content/<id>/attachments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["AttachmentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested custom content or the custom content was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentComments: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
            };
            header?: never;
            path: {
                /** @description The ID of the custom content for which comments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the custom content comments were successfully retrieved */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/custom-content/<id>/footer-comments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CustomContentCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     custom content or associated containers. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentLabels: {
        parameters: {
            query?: {
                /** @description Filter the results to labels based on their prefix. */
                prefix?: "my" | "team" | "global" | "system";
                /** @description Used to sort the result by a particular field. */
                sort?: string;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the custom content for which labels should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested labels are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/custom-content/<id>/labels?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Label"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom content for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent content of the requested custom content or the custom content was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the custom content for which content properties should be returned. */
                "custom-content-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/custom-content/<custom-content-id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified custom content or the custom content was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createCustomContentProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom content to create a property for. */
                "custom-content-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified custom content or the custom content was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom content for which content properties should be returned. */
                "custom-content-id": number;
                /** @description The ID of the content property being requested. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified custom content, the custom content was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateCustomContentPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom content the property belongs to. */
                "custom-content-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified custom content or the custom content was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteCustomContentPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom content the property belongs to. */
                "custom-content-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified custom content or the custom content was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getLabels: {
        parameters: {
            query?: {
                /** @description Filters on label ID. Multiple IDs can be specified as a comma-separated list. */
                "label-id"?: number[];
                /** @description Filters on label prefix. Multiple IDs can be specified as a comma-separated list. */
                prefix?: string[];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: string;
                /** @description Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested labels are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/labels?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Label"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getLabelAttachments: {
        parameters: {
            query?: {
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["AttachmentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the label for which attachments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested attachments for specified label were successfully fetched. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/labels/<id>/attachment?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["AttachmentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested label or label was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getLabelBlogPosts: {
        parameters: {
            query?: {
                /** @description Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list. */
                "space-id"?: number[];
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["BlogPostSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of blog posts per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the label for which blog posts should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested blog posts for specified label were successfully fetched. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/labels/<id>/blogposts?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["BlogPostBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested label or label was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getLabelPages: {
        parameters: {
            query?: {
                /** @description Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list. */
                "space-id"?: number[];
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["PageSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the label for which pages should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested pages for specified label were successfully fetched. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/labels/<id>/pages?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["PageBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested label or label was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPages: {
        parameters: {
            query?: {
                /** @description Filter the results based on page ids. Multiple page ids can be specified as a comma-separated list. */
                id?: number[];
                /** @description Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list. */
                "space-id"?: number[];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["PageSortOrder"];
                /** @description Filter the results to pages based on their status. By default, `current` and `archived` are used. */
                status?: ("current" | "archived" | "deleted" | "trashed")[];
                /** @description Filter the results to pages based on their title. */
                title?: string;
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Filter the results to pages based on their subtype. */
                subtype?: "live" | "page";
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested pages are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["PageBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createPage: {
        parameters: {
            query?: {
                /** @description Tag the content as embedded and content will be created in NCS. */
                embedded?: boolean;
                /** @description The page will be private. Only the user who creates this page will have permission to view and edit one. */
                private?: boolean;
                /** @description The page will be created at the root level of the space (outside the space homepage tree). If true, then a
                 *     value may not be supplied for the `parentId` body parameter. */
                "root-level"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["PageCreateRequest"];
        responses: {
            /** @description Returned if the page was successfully created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PageSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The space does not exist
             *     - The user does not have permissions to view the space
             *     - The user does not have the needed permissions to create a page in the provided space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the request is too large in size (over 5 MB). */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageById: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentationSingle"];
                /** @description Retrieve the draft version of this page. */
                "get-draft"?: boolean;
                /** @description Filter the page being retrieved by its status. */
                status?: ("current" | "archived" | "trashed" | "deleted" | "historical" | "draft")[];
                /** @description Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details. */
                version?: number;
                /** @description Includes labels associated with this page in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-labels"?: boolean;
                /** @description Includes content properties associated with this page in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
                /** @description Includes operations associated with this page in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes likes associated with this page in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-likes"?: boolean;
                /** @description Includes versions associated with this page in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-versions"?: boolean;
                /** @description Includes the current version associated with this page in the response.
                 *     By default this is included and can be omitted by setting the value to `false`. */
                "include-version"?: boolean;
                /** @description Includes whether this page has been favorited by the current user. */
                "include-favorited-by-current-user-status"?: boolean;
                /** @description Includes web resources that can be used to render page content on a client. */
                "include-webresources"?: boolean;
                /** @description Includes collaborators on the page. */
                "include-collaborators"?: boolean;
                /** @description Includes direct children of the page, as defined in the `ChildrenResponse` object. */
                "include-direct-children"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the page to be returned. If you don't know the page ID, use Get pages and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested page is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PageSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updatePage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["PageUpdateRequest"];
        responses: {
            /** @description Returned if the requested page is successfully updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PageSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided page does not exist
             *     - The user does not have permissions to view the page
             *     - The user does not have the needed permissions to update a page in the space
             *     - The user provides a parentId for a page that does not exist or they do not have permission to view
             *     - There are no spaces associated with the given spaceId */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deletePage: {
        parameters: {
            query?: {
                /** @description If attempting to purge the page. */
                purge?: boolean;
                /** @description If attempting to delete a page that is a draft. */
                draft?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the page to be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the page was successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided page does not exist
             *     - The user does not have permissions to view the page
             *     - The user does not have the needed permissions to delete a page in the space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageAttachments: {
        parameters: {
            query?: {
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["AttachmentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Filter the results to attachments based on their status. By default, `current` and `archived` are used. */
                status?: ("current" | "archived" | "trashed")[];
                /** @description Filters on the mediaType of attachments. Only one may be specified. */
                mediaType?: string;
                /** @description Filters on the file-name of attachments. Only one may be specified. */
                filename?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the page for which attachments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested attachments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/<id>/attachments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["AttachmentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentByTypeInPage: {
        parameters: {
            query: {
                /** @description The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content. */
                type: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CustomContentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
                 *
                 *     Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned. */
                "body-format"?: components["schemas"]["CustomContentBodyRepresentation"];
            };
            header?: never;
            path: {
                /** @description The ID of the page for which custom content should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested custom content is returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/{id}/custom-content?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CustomContentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the given page is not found. Returned if the type of custom content is not found. Note, this is distinct from the type being present, but no instances of the type, which would be a 200 with empty results. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageLabels: {
        parameters: {
            query?: {
                /** @description Filter the results to labels based on their prefix. */
                prefix?: "my" | "team" | "global" | "system";
                /** @description Used to sort the result by a particular field. */
                sort?: string;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the page for which labels should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested labels are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/<id>/labels?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Label"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageLikeCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page for which like count should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested count is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: int64
                         * @description The count number
                         */
                        count?: number;
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageLikeUsers: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the page for which like count should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested account IDs are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/<id>/likes/users?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Like"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent content of the requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the page for which content properties should be returned. */
                "page-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/<page-id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createPageProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page to create a property for. */
                "page-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page for which content properties should be returned. */
                "page-id": number;
                /** @description The ID of the content property being requested. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page, the page was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updatePagePropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page the property belongs to. */
                "page-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deletePagePropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page the property belongs to. */
                "page-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postRedactPage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page to redact content from. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["RedactionRequest"];
        responses: {
            /** @description Redaction Accepted. The response contains details about the redactions that were applied. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RedactionResponse"];
                };
            };
            /** @description Invalid request. This can be thrown if
             *     - createdAt field is out of date
             *     - JSON pointers are invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postRedactBlog: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post to redact content from. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["RedactionRequest"];
        responses: {
            /** @description Redaction Accepted. The response contains details about the redactions that were applied. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RedactionResponse"];
                };
            };
            /** @description Invalid request. This can be thrown if
             *     - createdAt field is out of date
             *     - JSON pointers are invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updatePageTitle: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["PageTitleUpdateRequest"];
        responses: {
            /** @description Returned if the requested page is successfully updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PageSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided page does not exist
             *     - The user does not have permissions to view the page
             *     - The user does not have the needed permissions to update a page in the space
             *     - The user provides a parentId for a page that does not exist or they do not have permission to view
             *     - There are no spaces associated with the given spaceId */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageVersions: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["VersionSortOrder"];
            };
            header?: never;
            path: {
                /** @description The ID of the page to be queried for its versions. If you don't know the page ID, use Get pages and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested page versions are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/<id>/versions?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["PageVersion"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createWhiteboard: {
        parameters: {
            query?: {
                /** @description The whiteboard will be private. Only the user who creates this whiteboard will have permission to view and edit one. */
                private?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["WhiteboardCreateRequest"];
        responses: {
            /** @description Returned if the whiteboard was successfully created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WhiteboardSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The space does not exist
             *     - The user does not have permissions to view the space
             *     - The user does not have the needed permissions to create a whiteboard in the provided space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the request is too large in size (over 5 MB). */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWhiteboardById: {
        parameters: {
            query?: {
                /** @description Includes collaborators on the whiteboard. */
                "include-collaborators"?: boolean;
                /** @description Includes direct children of the whiteboard, as defined in the `ChildrenResponse` object. */
                "include-direct-children"?: boolean;
                /** @description Includes operations associated with this whiteboard in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes content properties associated with this whiteboard in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the whiteboard to be returned */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested whiteboard is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WhiteboardSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested whiteboard or the whiteboard was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteWhiteboard: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard to be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the whiteboard was successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided whiteboard does not exist
             *     - The user does not have permissions to view the whiteboard
             *     - The user does not have the needed permissions to delete a whiteboard in the space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWhiteboardContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the whiteboard for which content properties should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/whiteboards/<id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified whiteboard or the whiteboard was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createWhiteboardProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard to create a property for. */
                id: number;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified whiteboard or the whiteboard was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWhiteboardContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard for which content properties should be returned. */
                "whiteboard-id": number;
                /** @description The ID of the content property being requested. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified whiteboard, the whiteboard was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateWhiteboardPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard the property belongs to. */
                "whiteboard-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified whiteboard or the whiteboard was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteWhiteboardPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard the property belongs to. */
                "whiteboard-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified whiteboard or the whiteboard was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWhiteboardOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested whiteboard or the whiteboard was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWhiteboardDirectChildren: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the parent whiteboard. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested children are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ChildrenResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWhiteboardDescendants: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results. */
                limit?: number;
                /** @description Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants. */
                depth?: number;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the whiteboard. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested descendants are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["DescendantsResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified whiteboard or the whiteboard was not found.
             *     content: { } */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWhiteboardAncestors: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the whiteboard. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested ancestors are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Ancestor"][];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified whiteboard or the whiteboard was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createDatabase: {
        parameters: {
            query?: {
                /** @description The database will be private. Only the user who creates this database will have permission to view and edit one. */
                private?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["DatabaseCreateRequest"];
        responses: {
            /** @description Returned if the database was successfully created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The space does not exist
             *     - The user does not have permissions to view the space
             *     - The user does not have the needed permissions to create a database in the provided space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the request is too large in size (over 5 MB). */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatabaseById: {
        parameters: {
            query?: {
                /** @description Includes collaborators on the database. */
                "include-collaborators"?: boolean;
                /** @description Includes direct children of the database, as defined in the `ChildrenResponse` object. */
                "include-direct-children"?: boolean;
                /** @description Includes operations associated with this database in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes content properties associated with this database in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the database to be returned */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested database is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DatabaseSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteDatabase: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database to be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the database was successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided database does not exist
             *     - The user does not have permissions to view the database
             *     - The user does not have the needed permissions to delete a database in the space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatabaseContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the database for which content properties should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/databases/<id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createDatabaseProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database to create a property for. */
                id: number;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatabaseContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database for which content properties should be returned. */
                "database-id": number;
                /** @description The ID of the content property being requested. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified database, the database was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateDatabasePropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database the property belongs to. */
                "database-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteDatabasePropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database the property belongs to. */
                "database-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatabaseOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatabaseDirectChildren: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the parent database. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested children are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ChildrenResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatabaseDescendants: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results. */
                limit?: number;
                /** @description Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants. */
                depth?: number;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the database. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested descendants are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["DescendantsResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatabaseAncestors: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the database. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested ancestors are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Ancestor"][];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified database or the database was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createSmartLink: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["SmartLinkCreateRequest"];
        responses: {
            /** @description Returned if the Smart Link was successfully created in the content tree. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SmartLinkSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The space does not exist
             *     - The user does not have permissions to view the space
             *     - The user does not have the needed permissions to create a Smart Link in the content tree in the provided space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the request is too large in size (over 5 MB). */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSmartLinkById: {
        parameters: {
            query?: {
                /** @description Includes collaborators on the Smart Link. */
                "include-collaborators"?: boolean;
                /** @description Includes direct children of the Smart Link, as defined in the `ChildrenResponse` object. */
                "include-direct-children"?: boolean;
                /** @description Includes operations associated with this Smart Link in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes content properties associated with this Smart Link in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree to be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested Smart Link in the content tree is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SmartLinkSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested Smart Link in the content tree or the Smart Link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteSmartLink: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree to be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the Smart Link in the content tree was successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided Smart Link in the content tree does not exist
             *     - The user does not have permissions to view the Smart Link in the content tree
             *     - The user does not have the needed permissions to delete a Smart Link in the content tree in the space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSmartLinkContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of Smart Links per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree for which content properties should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/embeds/<id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified Smart Link in the content tree or the Smart Link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createSmartLinkProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree to create a property for. */
                id: number;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified Smart Link in the content tree or the Smart Link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSmartLinkContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree for which content properties should be returned. */
                "embed-id": number;
                /** @description The ID of the content property being requested. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified Smart Link in the content tree, the Smart Link was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateSmartLinkPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree the property belongs to. */
                "embed-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified Smart Link in the content tree or the Smart Link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteSmartLinkPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree the property belongs to. */
                "embed-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified Smart Link in the content tree or the Smart Link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSmartLinkOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested Smart Link in the content tree or the Smart Link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSmartLinkDirectChildren: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the parent smart link. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested children are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ChildrenResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified smart link or the smart link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSmartLinkDescendants: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results. */
                limit?: number;
                /** @description Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants. */
                depth?: number;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the smart link. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested descendants are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["DescendantsResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified smart link or the smart link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSmartLinkAncestors: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the Smart Link in the content tree. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested ancestors are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Ancestor"][];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified Smart Link in the content tree or the Smart Link was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createFolder: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["FolderCreateRequest"];
        responses: {
            /** @description Returned if the folder was successfully created in the content tree. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The space does not exist
             *     - The user does not have permissions to view the space
             *     - The user does not have the needed permissions to create a folder in the provided space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the request is too large in size (over 5 MB). */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFolderById: {
        parameters: {
            query?: {
                /** @description Includes collaborators on the folder. */
                "include-collaborators"?: boolean;
                /** @description Includes direct children of the folder, as defined in the `ChildrenResponse` object. */
                "include-direct-children"?: boolean;
                /** @description Includes operations associated with this folder in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes content properties associated with this folder in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the folder to be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested folder is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FolderSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the folder to be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the folder was successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided folder does not exist
             *     - The user does not have permissions to view the folder
             *     - The user does not have the needed permissions to delete folder in the space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFolderContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the folder for which content properties should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/embeds/<id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createFolderProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the folder to create a property for. */
                id: number;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFolderContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the folder for which content properties should be returned. */
                "folder-id": number;
                /** @description The ID of the content property being requested. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified folder, the folder was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateFolderPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the folder the property belongs to. */
                "folder-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteFolderPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the folder the property belongs to. */
                "folder-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFolderOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the folder for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFolderDirectChildren: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the parent folder. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested children are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ChildrenResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFolderDescendants: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results. */
                limit?: number;
                /** @description Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants. */
                depth?: number;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the folder. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested descendants are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["DescendantsResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFolderAncestors: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the folder. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested ancestors are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Ancestor"][];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified folder or the folder was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageVersionDetails: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page for which version details should be returned. */
                "page-id": number;
                /** @description The version number of the page to be returned. */
                "version-number": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested version details are successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetailedVersion"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page, the page was not found, or the version number does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentVersions: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
                 *
                 *     Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned. */
                "body-format"?: components["schemas"]["CustomContentBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["VersionSortOrder"];
            };
            header?: never;
            path: {
                /** @description The ID of the custom content to be queried for its versions. If you don't know the custom content ID, use Get custom-content by type and filter the results. */
                "custom-content-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested custom content versions are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/custom-content/<id>/versions?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CustomContentVersion"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested custom content or the custom content was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentVersionDetails: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom content for which version details should be returned. */
                "custom-content-id": number;
                /** @description The version number of the custom content to be returned. */
                "version-number": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested version details are successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetailedVersion"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified custom content, the custom content was not found, or the version number does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaces: {
        parameters: {
            query?: {
                /** @description Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list. */
                ids?: number[];
                /** @description Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list. */
                keys?: string[];
                /** @description Filter the results to spaces based on their type. */
                type?: "global" | "collaboration" | "knowledge_base" | "personal";
                /** @description Filter the results to spaces based on their status. */
                status?: "current" | "archived";
                /** @description Filter the results to spaces based on their labels. Multiple labels can be specified as a comma-separated list. */
                labels?: string[];
                /** @description Filter the results to spaces favorited by the user with the specified account ID. */
                "favorited-by"?: string;
                /** @description Filter the results to spaces NOT favorited by the user with the specified account ID. */
                "not-favorited-by"?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["SpaceSortOrder"];
                /** @description The content format type to be returned in the `description` field of the response. If available, the representation will be available under a response field of the same name under the `description` field. */
                "description-format"?: components["schemas"]["SpaceDescriptionBodyRepresentation"];
                /** @description If the icon for the space should be fetched or not. */
                "include-icon"?: boolean;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested spaces are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/spaces?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["SpaceBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createSpace: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["SpaceCreateRequest"];
        responses: {
            /** @description Returned if the requested space is created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpaceBulk"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to create spaces. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the request is too large in size (over 5 MB). */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaceById: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `description` field of the response. If available, the representation will be available under a response field of the same name under the `description` field. */
                "description-format"?: components["schemas"]["SpaceDescriptionBodyRepresentation"];
                /** @description If the icon for the space should be fetched or not. */
                "include-icon"?: boolean;
                /** @description Includes operations associated with this space in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes space properties associated with this space in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
                /** @description Includes space permissions associated with this space in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-permissions"?: boolean;
                /** @description Includes role assignments associated with this space in the response. This parameter is only accepted for EAP sites.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-role-assignments"?: boolean;
                /** @description Includes labels associated with this space in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-labels"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the space to be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested space is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpaceSingle"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostsInSpace: {
        parameters: {
            query?: {
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["BlogPostSortOrder"];
                /** @description Filter the results to blog posts based on their status. By default, `current` is used. */
                status?: ("current" | "deleted" | "trashed")[];
                /** @description Filter the results to blog posts based on their title. */
                title?: string;
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of blog posts per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the space for which blog posts should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested blog posts are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/spaces/<id>/blogposts?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["BlogPostBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaceLabels: {
        parameters: {
            query?: {
                /** @description Filter the results to labels based on their prefix. */
                prefix?: "my" | "team";
                /** @description Used to sort the result by a particular field. */
                sort?: string;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the space for which labels should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested labels are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/spaces/<id>/labels?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Label"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaceContentLabels: {
        parameters: {
            query?: {
                /** @description Filter the results to labels based on their prefix. */
                prefix?: "my" | "team";
                /** @description Used to sort the result by a particular field. */
                sort?: string;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the space for which labels should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested labels are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/spaces/<id>/labels?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Label"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomContentByTypeInSpace: {
        parameters: {
            query: {
                /** @description The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content. */
                type: string;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
                 *
                 *     Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned. */
                "body-format"?: components["schemas"]["CustomContentBodyRepresentation"];
            };
            header?: never;
            path: {
                /** @description The ID of the space for which custom content should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested custom content is returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/spaces/{id}/custom-content?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CustomContentBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the space is not found. Returned if the type of custom content is not found. Note, this is distinct from the type being present, but no instances of the type, which would be a 200 with empty results. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaceOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPagesInSpace: {
        parameters: {
            query?: {
                /** @description Filter the results to pages at the root level of the space or to all pages in the space. */
                depth?: "all" | "root";
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["PageSortOrder"];
                /** @description Filter the results to pages based on their status. By default, `current` and `archived` are used. */
                status?: ("current" | "archived" | "deleted" | "trashed")[];
                /** @description Filter the results to pages based on their title. */
                title?: string;
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the space for which pages should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested pages are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/spaces/<id>/pages?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["PageBulk"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaceProperties: {
        parameters: {
            query?: {
                /** @description The key of the space property to retrieve. This should be used when a user knows the key of their property, but needs to retrieve the id for use in other methods. */
                key?: string;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the space for which space properties should be returned. */
                "space-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested space properties are returned. `results` may be empty if no results were found. */
            200: {
                headers: {
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["SpaceProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createSpaceProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space for which space properties should be returned. */
                "space-id": number;
            };
            cookie?: never;
        };
        /** @description The space property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SpacePropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the space property was created successfully. */
            201: {
                headers: {
                    location?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpaceProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpacePropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space the property belongs to. */
                "space-id": number;
                /** @description The ID of the property to be retrieved. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the space property was retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpaceProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateSpacePropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space the property belongs to. */
                "space-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The space property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SpacePropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the space property was updated successfully. */
            200: {
                headers: {
                    location?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpaceProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteSpacePropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space the property belongs to. */
                "space-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the space property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpacePermissionsAssignments: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of assignments to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the space to be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested assignments are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["SpacePermissionAssignment"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested space permission assignments or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAvailableSpacePermissions: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of space permissions to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested space permissions are retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["SpacePermission"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     available space permissions. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAvailableSpaceRoles: {
        parameters: {
            query?: {
                /** @description The space ID for which to filter available space roles; if empty, return all available space roles for the tenant. */
                "space-id"?: string;
                /** @description The space role type to filter results by. */
                "role-type"?: string;
                /** @description The principal ID to filter results by. If specified, a principal-type must also be specified. Paired with a `principal-type` of `ACCESS_CLASS`, valid values include [`anonymous-users`, `jsm-project-admins`, `authenticated-users`, `all-licensed-users`, `all-product-admins`] */
                "principal-id"?: string;
                /** @description The principal type to filter results by. If specified, a principal-id must also be specified. */
                "principal-type"?: components["schemas"]["PrincipalType"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of space roles to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested space roles are retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["SpaceRole"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     available space roles. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaceRolesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space role to retrieve. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested space role is retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SpaceRole"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     space role. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaceRoleAssignments: {
        parameters: {
            query?: {
                /** @description Filters the returned role assignments to the provided role ID. */
                "role-id"?: string;
                /** @description Filters the returned role assignments to the provided role type. */
                "role-type"?: string;
                /** @description Filters the returned role assignments to the provided principal id. If specified, a principal-type must also be specified. Paired with a `principal-type` of `ACCESS_CLASS`, valid values include [`anonymous-users`, `jsm-project-admins`, `authenticated-users`, `all-licensed-users`, `all-product-admins`] */
                "principal-id"?: string;
                /** @description Filters the returned role assignments to the provided principal type. If specified, a principal-id must also be specified. */
                "principal-type"?: components["schemas"]["PrincipalType"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of space roles to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the space for which to retrieve assignments. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested space role assignments are retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["SpaceRoleAssignment"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     space or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    setSpaceRoleAssignments: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space for which to retrieve assignments. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["SetSpaceRoleAssignmentRequest"];
        responses: {
            /** @description Returned if the requested update to space role assignments succeeds in its entirety. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["SpaceRoleAssignment"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to set roles in the space, or the space was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the request is too large in size (over 5 MB). */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageFooterComments: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Filter the footer comment being retrieved by its status. */
                status?: ("current" | "archived" | "trashed" | "deleted" | "historical" | "draft")[];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the page for which footer comments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested footer comments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/<id>/footer-comments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["PageCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageInlineComments: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Filter the inline comment being retrieved by its status. */
                status?: ("current" | "archived" | "trashed" | "deleted" | "historical" | "draft")[];
                /** @description Filter the inline comment being retrieved by its resolution status. */
                "resolution-status"?: ("resolved" | "open" | "dangling" | "reopened")[];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of inline comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the page for which inline comments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested inline comments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/<id>/inline-comments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["PageInlineCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostFooterComments: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Filter the footer comment being retrieved by its status. */
                status?: ("current" | "deleted" | "trashed" | "historical" | "draft")[];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the blog post for which footer comments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested footer comments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/<id>/footer-comments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["BlogPostCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostInlineComments: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Filter the inline comment being retrieved by its status. */
                status?: ("current" | "deleted" | "trashed" | "historical" | "draft")[];
                /** @description Filter the inline comment being retrieved by its resolution status. */
                "resolution-status"?: ("resolved" | "open" | "dangling" | "reopened")[];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of inline comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the blog post for which inline comments should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested inline comments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/blogposts/<id>/inline-comments?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["BlogPostInlineCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested blog post or the blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFooterComments: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested footer comments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/footer-comments/<id>/children?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["FooterCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createFooterComment: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The footer comment to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateFooterCommentModel"];
            };
        };
        responses: {
            /** @description Returned if the footer comment is created. */
            201: {
                headers: {
                    /** @description Returns the URL at which the created footer comment is retrievable.
                     *      */
                    location?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FooterCommentModel"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The page, blog post, parent comment, or attachment was not found
             *     - The calling user does not have permission to view the parent page/blog post
             *     - The user is forbidden from creating a comment tied to a resource they are allowed to view */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFooterCommentById: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentationSingle"];
                /** @description Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details. */
                version?: number;
                /** @description Includes content properties associated with this footer comment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
                /** @description Includes operations associated with this footer comment in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes likes associated with this footer comment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-likes"?: boolean;
                /** @description Includes versions associated with this footer comment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-versions"?: boolean;
                /** @description Includes the current version associated with this footer comment in the response.
                 *     By default this is included and can be omitted by setting the value to `false`. */
                "include-version"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the comment to be retrieved. */
                "comment-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the footer comment is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FooterCommentModel"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateFooterComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the comment to be retrieved. */
                "comment-id": number;
            };
            cookie?: never;
        };
        /** @description The footer comment to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateFooterCommentModel"] & {
                    _links?: {
                        /** @description Base url of the Confluence site. */
                        base?: string;
                    };
                };
            };
        };
        responses: {
            /** @description Returned if the footer comment is updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FooterCommentModel"];
                };
            };
            /** @description Returned if an invalid request is provided */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The comment was not found
             *     - The calling user does not have permission to view the comment
             *     - The user is forbidden from updating a comment tied to a resource they are allowed to view */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteFooterComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the comment to be retrieved. */
                "comment-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the footer comment is deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The comment was not found
             *     - The calling user does not have permission to view the comment
             *     - The user is forbidden from deleting a comment tied to a resource they are allowed to view */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFooterCommentChildren: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the parent comment for which footer comment children should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested footer comments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/footer-comments/<id>/children?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ChildrenCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent page/blog post or the page/blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFooterLikeCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the footer comment for which like count should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested count is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: int64
                         * @description The count number
                         */
                        count?: number;
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFooterLikeUsers: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the footer comment for which like count should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested account IDs are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/footer-comments/<id>/likes/users?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Like"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFooterCommentOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the footer comment for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent content of the requested footer comment or the footer comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFooterCommentVersions: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["VersionSortOrder"];
            };
            header?: never;
            path: {
                /** @description The ID of the footer comment for which versions should be returned */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested footer comment versions are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/footer-comments/<id>/versions?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CommentVersion"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the specified page
             *     or blog post, the footer comment was not found, or the version number does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getFooterCommentVersionDetails: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the footer comment for which version details should be returned. */
                id: number;
                /** @description The version number of the footer comment to be returned. */
                "version-number": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested version details are successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetailedVersion"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the specified page
             *     or blog post, the footer comment was not found, or the version number does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInlineComments: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested inline comments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/inline-comments/<id>/children?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["InlineCommentModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createInlineComment: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The inline comment to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateInlineCommentModel"];
            };
        };
        responses: {
            /** @description Returned if the inline comment is created. */
            201: {
                headers: {
                    /** @description Returns the URL at which the created inline comment is retrievable.
                     *      */
                    location?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InlineCommentModel"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The page/blog post was not found
             *     - The calling user does not have permission to view the parent page/blog post
             *     - The user is forbidden from creating a comment tied to a resource they are allowed to view */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInlineCommentById: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentationSingle"];
                /** @description Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details. */
                version?: number;
                /** @description Includes content properties associated with this inline comment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-properties"?: boolean;
                /** @description Includes operations associated with this inline comment in the response, as defined in the `Operation` object.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-operations"?: boolean;
                /** @description Includes likes associated with this inline comment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-likes"?: boolean;
                /** @description Includes versions associated with this inline comment in the response.
                 *     The number of results will be limited to 50 and sorted in the default sort order.
                 *     A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results. */
                "include-versions"?: boolean;
                /** @description Includes the current version associated with this inline comment in the response.
                 *     By default this is included and can be omitted by setting the value to `false`. */
                "include-version"?: boolean;
            };
            header?: never;
            path: {
                /** @description The ID of the comment to be retrieved. */
                "comment-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the inline comment is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InlineCommentModel"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateInlineComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the comment to be retrieved. */
                "comment-id": number;
            };
            cookie?: never;
        };
        /** @description The inline comment to be updated */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateInlineCommentModel"];
            };
        };
        responses: {
            /** @description Returned if the inline comment is updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InlineCommentModel"] & {
                        _links?: {
                            /** @description Base url of the Confluence site. */
                            base?: string;
                        };
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The comment was not found
             *     - The calling user does not have permission to view the comment
             *     - The user is forbidden from updating a comment tied to a resource they are allowed to view */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteInlineComment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the comment to be deleted. */
                "comment-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the inline comment is deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The comment was not found
             *     - The calling user does not have permission to view the comment
             *     - The user is forbidden from deleting a comment tied to a resource they are allowed to view */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInlineCommentChildren: {
        parameters: {
            query?: {
                /** @description The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["CommentSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the parent comment for which inline comment children should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested footer comments are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/inline-comments/<id>/children?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["InlineCommentChildrenModel"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent page/blog post or the page/blog post was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInlineLikeCount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the inline comment for which like count should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested count is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: int64
                         * @description The count number
                         */
                        count?: number;
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInlineLikeUsers: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the inline comment for which like count should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested account IDs are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/inline-comments/<id>/likes/users?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Like"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInlineCommentOperations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the inline comment for which operations should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested operations are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PermittedOperationsResponse"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     parent content of the requested inline comment or the inline comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInlineCommentVersions: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["VersionSortOrder"];
            };
            header?: never;
            path: {
                /** @description The ID of the inline comment for which versions should be returned */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested inline comment versions are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/inline-comments/<id>/versions?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["CommentVersion"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the specified page
             *     or blog post, the inline comment was not found, or the version number does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getInlineCommentVersionDetails: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the inline comment for which version details should be returned. */
                id: number;
                /** @description The version number of the inline comment to be returned. */
                "version-number": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested version details are successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DetailedVersion"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the specified page
             *     or blog post, the inline comment was not found, or the version number does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCommentContentProperties: {
        parameters: {
            query?: {
                /** @description Filters the response to return a specific content property with matching key (case sensitive). */
                key?: string;
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["ContentPropertySortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the comment for which content properties should be returned. */
                "comment-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content properties are successfully retrieved. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/comments/<comment-id>/properties?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ContentProperty"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createCommentProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the comment to create a property for. */
                "comment-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be created */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyCreateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was created successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCommentContentPropertiesById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the comment for which content properties should be returned. */
                "comment-id": number;
                /** @description The ID of the content property being requested. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested content property is successfully retrieved. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified comment, the comment was not found, or the property was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateCommentPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the comment the property belongs to. */
                "comment-id": number;
                /** @description The ID of the property to be updated. */
                "property-id": number;
            };
            cookie?: never;
        };
        /** @description The content property to be updated. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ContentPropertyUpdateRequest"];
            };
        };
        responses: {
            /** @description Returned if the content property was updated successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ContentProperty"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteCommentPropertyById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the comment the property belongs to. */
                "comment-id": number;
                /** @description The ID of the property to be deleted. */
                "property-id": number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the content property was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified comment or the comment was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTasks: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
                /** @description Specifies whether to include blank tasks in the response. Defaults to `true`. */
                "include-blank-tasks"?: boolean;
                /** @description Filters on the status of the task. */
                status?: "complete" | "incomplete";
                /** @description Filters on task ID. Multiple IDs can be specified. */
                "task-id"?: number[];
                /** @description Filters on the space ID of the task. Multiple IDs can be specified. */
                "space-id"?: number[];
                /** @description Filters on the page ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction. */
                "page-id"?: number[];
                /** @description Filters on the blog post ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction. */
                "blogpost-id"?: number[];
                /** @description Filters on the Account ID of the user who created this task. Multiple IDs can be specified. */
                "created-by"?: string[];
                /** @description Filters on the Account ID of the user to whom this task is assigned. Multiple IDs can be specified. */
                "assigned-to"?: string[];
                /** @description Filters on the Account ID of the user who completed this task. Multiple IDs can be specified. */
                "completed-by"?: string[];
                /** @description Filters on start of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds. */
                "created-at-from"?: number;
                /** @description Filters on end of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds. */
                "created-at-to"?: number;
                /** @description Filters on start of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds. */
                "due-at-from"?: number;
                /** @description Filters on end of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds. */
                "due-at-to"?: number;
                /** @description Filters on start of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds. */
                "completed-at-from"?: number;
                /** @description Filters on end of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds. */
                "completed-at-to"?: number;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of tasks per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested tasks are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/tasks?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Task"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTaskById: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
            };
            header?: never;
            path: {
                /** @description The ID of the task to be returned. If you don't know the task ID, use Get tasks and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested task is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Task"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     requested task or the task was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    updateTask: {
        parameters: {
            query?: {
                /** @description The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field. */
                "body-format"?: components["schemas"]["PrimaryBodyRepresentation"];
            };
            header?: never;
            path: {
                /** @description The ID of the task to be updated. If you don't know the task ID, use Get tasks and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["TaskUpdateRequest"];
        responses: {
            /** @description Returned if the requested task is updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Task"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - The provided task does not exist
             *     - The user does not have permissions to view the task
             *     - The user does not have the needed permissions to update the containing page or blog post in the corresponding space */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getChildPages: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the parent page. If you don't know the page ID, use Get pages and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested child pages are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/pages/{id}/children?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ChildPage"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getChildCustomContent: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the parent custom content. If you don't know the custom content ID, use Get custom-content and filter the results. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested child custom content are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/custom-content/{id}/children?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ChildCustomContent"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageDirectChildren: {
        parameters: {
            query?: {
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
                /** @description Used to sort the result by a particular field. */
                sort?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the parent page. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested children are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["ChildrenResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageAncestors: {
        parameters: {
            query?: {
                /** @description Maximum number of pages per result to return. If more results exist, call this endpoint with the highest ancestor's ID to fetch the next set of results. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the page. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested ancestors are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["Ancestor"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageDescendants: {
        parameters: {
            query?: {
                /** @description Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results. */
                limit?: number;
                /** @description Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants. */
                depth?: number;
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the page. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested descendants are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["DescendantsResponse"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to view the
             *     specified page or the page was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createBulkUserLookup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["BulkUsersRequest"];
        responses: {
            /** @description Returned if the user info is returned for the account IDs. `results` may be empty if no account IDs were found. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL. Example response header format: <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["User"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to use Confluence or view user profiles. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    checkAccessByEmail: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CheckAccessOrInviteByEmailRequest"];
        responses: {
            /** @description Returns object with list of emails without access to site. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of emails that do not have access to site. */
                        emailsWithoutAccess?: string[];
                        /** @description List of invalid emails provided in the request. */
                        invalidEmails?: string[];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to check access for emails on site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if API is disabled on site */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    inviteByEmail: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["CheckAccessOrInviteByEmailRequest"];
        responses: {
            /** @description Returns object with list of emails without access to site. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the calling user does not have permission to check access for emails on site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if API is disabled on site */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataPolicyMetadata: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the request is successful. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataPolicyMetadata"];
                };
            };
            /** @description Returned if the request is not valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDataPolicySpaces: {
        parameters: {
            query?: {
                /** @description Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list. */
                ids?: number[];
                /** @description Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list. */
                keys?: string[];
                /** @description Used to sort the result by a particular field. */
                sort?: components["schemas"]["SpaceSortOrder"];
                /** @description Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results. */
                cursor?: string;
                /** @description Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested spaces are returned. */
            200: {
                headers: {
                    /** @description This header contains URL(s) within angle brackets and a relation description for each URL, describing how the provided URL relates to the incoming request's URL.
                     *     For example, rel="next" would be the URL necessary to get the next page of information. Example response header format: `Link: </wiki/api/v2/spaces?cursor=<opaque cursor token>>; rel="next", <https://site.atlassian.net/wiki>; rel="base"`
                     *      */
                    Link?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        results?: components["schemas"]["DataPolicySpace"][];
                        _links?: components["schemas"]["MultiEntityLinks"];
                    };
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getClassificationLevels: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if classifications levels are returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClassificationLevel"][];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Classification levels do not exist
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permissions to access the Confluence site
             *      */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSpaceDefaultClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space for which default classification level should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested default classification level for a space is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClassificationLevel"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Default classification level is not applied to the space
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to view the specified space or the space was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putSpaceDefaultClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space for which default classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["SpaceDefaultClassificationLevelUpdateRequest"];
        responses: {
            /** @description Returned if the default classification level was successfully updated. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to view the specified space or the space was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteSpaceDefaultClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the space for which default classification level should be deleted. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the default classification level was successfully deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to view the specified space or the space was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getPageClassificationLevel: {
        parameters: {
            query?: {
                /** @description Status of page from which classification level will fetched. */
                status?: "current" | "draft" | "archived";
            };
            header?: never;
            path: {
                /** @description The ID of the page for which classification level should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested classification level for a page is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClassificationLevel"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Page does not have a classification level applied
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to view the specified page or the page was not found
             *     - The calling user does not have permission to edit the specified page when trying to fetch classification level for a draft */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putPageClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page for which classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["ContentClassificationLevelUpdateRequest"];
        responses: {
            /** @description Returned if the classification level was successfully updated. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to edit the specified page or the page was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postPageClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the page for which classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["ContentClassificationLevelDeleteRequest"];
        responses: {
            /** @description Returned if the classification level was successfully reset. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to edit the specified page or the page was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getBlogPostClassificationLevel: {
        parameters: {
            query?: {
                /** @description Status of blog post from which classification level will fetched. */
                status?: "current" | "draft" | "archived";
            };
            header?: never;
            path: {
                /** @description The ID of the blog post for which classification level should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested classification level for a blog post is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClassificationLevel"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Blog post does not have a classification level applied
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to view the specified blog post or the blog post was not found
             *     - The calling user does not have permission to edit the specified blog post when trying to fetch classification level for a draft */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putBlogPostClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post for which classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["ContentClassificationLevelUpdateRequest"];
        responses: {
            /** @description Returned if the classification level was successfully updated. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to edit the specified blog post or the blog post was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postBlogPostClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the blog post for which classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["ContentClassificationLevelDeleteRequest"];
        responses: {
            /** @description Returned if the classification level was successfully reset. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to edit the specified blog post or the blog post was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getWhiteboardClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard for which classification level should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested classification level for a whiteboard is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClassificationLevel"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Whiteboard does not have a classification level applied
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to view the specified whiteboard, or the whiteboard was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putWhiteboardClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard for which classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["LiveEditContentClassificationLevelUpdateRequest"];
        responses: {
            /** @description Returned if the classification level was successfully updated. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to edit the specified whiteboard
             *     - The whiteboard or classification level was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postWhiteboardClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the whiteboard for which classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["LiveEditContentClassificationLevelResetRequest"];
        responses: {
            /** @description Returned if the classification level was successfully reset. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to edit the specified whiteboard, or the whiteboard was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getDatabaseClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database for which classification level should be returned. */
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Returned if the requested classification level for a database is returned. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClassificationLevel"];
                };
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Database does not have a classification level applied
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to view the specified database, or the database was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putDatabaseClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database for which classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["LiveEditContentClassificationLevelUpdateRequest"];
        responses: {
            /** @description Returned if the classification level was successfully updated. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to edit the specified database
             *     - The database or the classification level was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    postDatabaseClassificationLevel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the database for which classification level should be updated. */
                id: number;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["LiveEditContentClassificationLevelResetRequest"];
        responses: {
            /** @description Returned if the classification level was successfully reset. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if an invalid request is provided. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if the authentication credentials are incorrect or missing
             *     from the request. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned if:
             *     - Site's edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
             *     - The calling user does not have permission to edit the specified database, or the database was not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    putForgeAppProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the property */
                propertyKey: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": Record<string, never>;
            };
        };
        responses: {
            /** @description Property updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Property created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Property key longer than 127 characters, or request made with invalid JSON. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request did not originate from the Forge app. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned when the request is forbidden due to one of the following:
             *     - The request attempts impersonation. Only requests made using `asApp()` are allowed.
             *     - The Forge app is not installed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteForgeAppProperty: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The key of the property */
                propertyKey: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Property deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Property key longer than 127 characters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The request did not originate from the Forge app. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Returned when the request is forbidden due to one of the following:
             *     - The request attempts impersonation. Only requests made using `asApp()` are allowed.
             *     - The Forge app is not installed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
